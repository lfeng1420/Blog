<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[使用Windbg简单分析托管程序dump]]></title>
      <url>/blog/2018/Analyze-CLR-application-dump-with-windbg.html</url>
      <content type="html"><![CDATA[<p>&emsp; &emsp;分析dump之前，需要先从微软符号服务器下载分析所需的pdb。打开Windbg，选择<code>File-&gt;Symbol File Path</code>，在弹出的符号路径设置窗口中输入以下内容并点击<code>OK</code>，也可以使用<code>.sympath+</code>命令（需要先打开dump）：<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRV*F:\SymbolCache*http://symbols.mozilla.org/firefox;SRV*F:\SymbolCache*http://msdl.microsoft.com/download/symbols;</span><br></pre></td></tr></table></figure></p>
<p>&emsp; &emsp;其中，<code>F:\SymbolCache</code>替换为要存放pdb的路径，这里也可以预先在后面加上项目的pdb所在路径。</p>
<p><div align="center"><img src="../images/2018/Analyze-CLR-application-dump-with-windbg/1.png" alt=""></div><br>&emsp; &emsp;通过<code>File-&gt;Open Crash Dump</code>打开dump文件，添加项目的符号路径（<code>.sympath+</code>命令或<code>File-&gt; Symbol File Path</code>，如果已经预先添加过了则忽略），之后输入<code>.reload /f</code>强制重新加载符号，如果之前没有下载过符号，则需要等待比较长的时间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; .reload /f</span><br><span class="line">.*** WARNING: Unable to verify checksum for AppFrame.exe</span><br><span class="line">.............................*** WARNING: Unable to verify checksum for DLog.dll</span><br><span class="line">.*** ERROR: Symbol file could not be found.  Defaulted to export symbols for SocketSystem2012.dll - </span><br><span class="line">...*** WARNING: Unable to verify checksum for SceneServer.dll</span><br><span class="line">..........*** WARNING: Unable to verify checksum for Base_d.dll</span><br><span class="line">..................*** WARNING: Unable to verify checksum for ZoneServerLogic.DLL</span><br><span class="line">..</span><br><span class="line">.......*** WARNING: Unable to verify checksum for CenterServer_d.dll</span><br><span class="line">*** ERROR: Symbol file could not be found.  Defaulted to export symbols for CenterServer_d.dll - </span><br><span class="line">.*** WARNING: Unable to verify checksum for GatewayServer_d.dll</span><br><span class="line">*** ERROR: Symbol file could not be found.  Defaulted to export symbols for GatewayServer_d.dll - </span><br><span class="line">.*** ERROR: Symbol file could not be found.  Defaulted to export symbols for basetoolsA.dll - </span><br><span class="line">.*** ERROR: Symbol file could not be found.  Defaulted to export symbols for DataCenter.dll - </span><br><span class="line">.*** WARNING: Unable to verify checksum for EnterManager.DLL</span><br><span class="line">.*** WARNING: Unable to verify checksum for RoomServer.DLL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Press ctrl-c (cdb, kd, ntsd) or ctrl-break (windbg) to abort symbol loads that take too long.</span><br><span class="line">Run !sym noisy before .reload to track down problems loading symbols.</span><br><span class="line"></span><br><span class="line">.*** WARNING: Unable to verify checksum for BattleModuleWrapper.DLL</span><br><span class="line">.....*** WARNING: Unable to verify checksum for mscorlib.ni.dll</span><br><span class="line">...*** WARNING: Unable to verify checksum for System.ni.dll</span><br><span class="line">.*** WARNING: Unable to verify checksum for System.Xml.ni.dll</span><br><span class="line">..*** WARNING: Unable to verify checksum for System.Core.ni.dll</span><br><span class="line">....</span><br><span class="line">Loading unloaded module list</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>&emsp; &emsp;当出现<code>Loading unloaded module list</code>时，输入<code>.chain</code>命令查看当前已加载的扩展：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; .chain</span><br><span class="line">Extension DLL search Path:</span><br><span class="line">    H:\Program\Debugging Tools for Windows (x86)\WINXP;H:\Program\Debugging Tools for Windows (x86)\winext;H:\Program\Debugging Tools for Windows (x86)\winext\arcade;H:\Program\Debugging Tools for Windows (x86)\pri;H:\Program\Debugging Tools for Windows (x86);H:\Program\Debugging Tools for Windows (x86)\winext\arcade;D:\Program\Perl\site\bin;D:\Program\Perl\bin;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\ProgramData\Oracle\Java\javapath;C:\Program Files (x86)\Intel\iCLS Client\;C:\Program Files\Intel\iCLS Client\;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\IPT;E:\Software\Program\Python27\;E:\Software\Program\Lua\5.1;E:\Software\Program\Lua\5.1\clibs;C:\strawberry\c\bin;C:\strawberry\perl\bin;H:\Program\Java\jdk1.8.0_65\bin;H:\Program\Java\jdk1.8.0_65\jre\bin;E:\Software\Program\Git\cmd;E:\Software\Program\Subversion\bin;E:\Software\Program\Subversion\bin;E:\Software\Program\MySQL\MySQL Server 5.5\bin;C:\Program Files (x86)\AMD\ATI.ACE\Core-Static;D:\Program\php;D:\Program\php\ext;C:\Program Files\TortoiseSVN\bin;E:\Software\Program\CMake\bin;C:\Program Files (x86)\Windows Kits\8.1\Windows Performance Toolkit\;C:\Program Files (x86)\Microsoft SDKs\TypeScript\1.0\;C:\Program Files (x86)\GtkSharp\2.12\bin;D:\Program\Redis\;C:\Program Files (x86)\Common Files\Adobe\AGL;D:\Program\NASM;C:\Program Files\Microsoft SQL Server\130\Tools\Binn\;E:\Software\Program\cocos2d-x-3.2\tools\cocos2d-console\bin;C:\Program Files (x86)\Debugging Tools for Windows;D:\Program\Microsoft VS Code\bin</span><br><span class="line">Extension DLL chain:</span><br><span class="line">    C:\Windows\Microsoft.NET\Framework\v4.0.30319\sos: image 4.6.1055.0, API 1.0.0, built Fri Nov 06 10:20:58 2015</span><br><span class="line">        [path: C:\Windows\Microsoft.NET\Framework\v4.0.30319\sos.dll]</span><br><span class="line">    dbghelp: image 6.12.0002.633, API 6.1.6, built Tue Feb 02 04:08:26 2010</span><br><span class="line">        [path: H:\Program\Debugging Tools for Windows (x86)\dbghelp.dll]</span><br><span class="line">    ext: image 6.12.0002.633, API 1.0.0, built Tue Feb 02 04:08:31 2010</span><br><span class="line">        [path: H:\Program\Debugging Tools for Windows (x86)\winext\ext.dll]</span><br><span class="line">    exts: image 6.12.0002.633, API 1.0.0, built Tue Feb 02 04:08:24 2010</span><br><span class="line">        [path: H:\Program\Debugging Tools for Windows (x86)\WINXP\exts.dll]</span><br><span class="line">    uext: image 6.12.0002.633, API 1.0.0, built Tue Feb 02 04:08:23 2010</span><br><span class="line">        [path: H:\Program\Debugging Tools for Windows (x86)\winext\uext.dll]</span><br><span class="line">    ntsdexts: image 6.1.7650.0, API 1.0.0, built Tue Feb 02 04:08:08 2010</span><br><span class="line">        [path: H:\Program\Debugging Tools for Windows (x86)\WINXP\ntsdexts.dll]</span><br></pre></td></tr></table></figure></p>
<p>&emsp; &emsp;可以看到这里已经加载了<code>sos.dll</code>，如果遇到没有<code>sos.dll</code>的情况，可以输入<code>.load C:\Windows\Microsoft.NET\Framework64\v4.0.30319\sos.dll</code>加载dll。加载之前请先确认SOS 调试扩展 (sos.dll) 的版本与 CLR 和 DAC 的版本匹配: v4.0.30319，以及三个组件都是64位（这一句来自微软官方文档，我也不太明白是啥意思）。另外也可以输入<code>.loadby sos clr</code>（CLR版本4.0及以上，1.0或2.0版本输入<code>.loadby sos mscorwks</code>）加载<code>sos.dll</code>。<br>&emsp; &emsp;接下来，输入<code>!clrstack</code>即可看到托管堆栈信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; !clrstack</span><br><span class="line">OS Thread Id: 0x1430 (4)</span><br><span class="line">Child SP       IP Call Site</span><br><span class="line">03f67be8 77020c52 [InlinedCallFrame: 03f67be8] </span><br><span class="line">03f67b54 037358c4 &lt;Module&gt;.CBattleModuleWrapper.Create(CBattleModuleWrapper*) [f:\xxx\server\battle\battlemodulewrapper\battlemodulewrapper.cpp @ 46]</span><br><span class="line">03f67b78 037351b7 DomainBoundILStubClass.IL_STUB_ReversePInvoke(Int32)</span><br><span class="line">03f67be8 03b3e29a [InlinedCallFrame: 03f67be8] </span><br><span class="line">03f67be4 03735125 DomainBoundILStubClass.IL_STUB_PInvoke(IntPtr)</span><br><span class="line">03f67c34 037330a8 &lt;Module&gt;.CreateBattleModuleWrapper() [f:\xxx\server\battle\battlemodulewrapper\battlemodulewrapper.cpp @ 192]</span><br></pre></td></tr></table></figure></p>
<p>&emsp; &emsp;输入<code>!clrstack -a</code>还可以看到调用堆栈传入参数信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">0:004&gt; !clrstack -a</span><br><span class="line">OS Thread Id: 0x1430 (4)</span><br><span class="line">Child SP       IP Call Site</span><br><span class="line">03f67be8 77020c52 [InlinedCallFrame: 03f67be8] Unknown</span><br><span class="line">03f67b54 037358c4 &lt;Module&gt;.CBattleModuleWrapper.Create(CBattleModuleWrapper*) [f:\xxx\server\battle\battlemodulewrapper\battlemodulewrapper.cpp @ 46]</span><br><span class="line">    PARAMETERS:</span><br><span class="line">        軰ˉˏd (0x03f67b6c) = 0x05812178</span><br><span class="line">    LOCALS:</span><br><span class="line">        0x03f67b64 = 0x074e2fd0</span><br><span class="line">        0x03f67b60 = 0x0749229c</span><br><span class="line">        0x03f67b68 = 0x00000000</span><br><span class="line">        0x03f67b5c = 0x00000000</span><br><span class="line"></span><br><span class="line">03f67b78 037351b7 DomainBoundILStubClass.IL_STUB_ReversePInvoke(Int32)</span><br><span class="line">    PARAMETERS:</span><br><span class="line">        &lt;no data&gt;</span><br><span class="line"></span><br><span class="line">03f67be8 03b3e29a [InlinedCallFrame: 03f67be8] </span><br><span class="line">03f67be4 03735125 DomainBoundILStubClass.IL_STUB_PInvoke(IntPtr)</span><br><span class="line">    PARAMETERS:</span><br><span class="line">        &lt;no data&gt;</span><br><span class="line"></span><br><span class="line">03f67c34 037330a8 &lt;Module&gt;.CreateBattleModuleWrapper() [f:\xxx\server\battle\battlemodulewrapper\battlemodulewrapper.cpp @ 192]</span><br><span class="line">    LOCALS:</span><br><span class="line">        0x03f67c58 = 0x05812178</span><br><span class="line">        0x03f67c54 = 0x00000000</span><br><span class="line">        0x03f67c50 = 0x05812178</span><br><span class="line">        0x03f67c4c = 0x05812178</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> windbg </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windbg </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Github和hexo搭建个人博客（多图）]]></title>
      <url>/blog/2018/Build-personal-blog-with-github-and-hexo.html</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果希望阅读简洁的版本，请前往hexo官方查阅文档，戳<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener"><strong>这里</strong></a><a id="more"></a></p>
<h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><hr>
<p>&emsp;&emsp;下载地址：<a href="https://github.com/git-for-windows/git/releases/download/v2.16.3.windows.1/Git-2.16.3-64-bit.exe" target="_blank" rel="noopener">Git (2.16.3, x64)</a><br>&emsp;&emsp;下载完成后，打开exe进行安装。第一步是阅读GNU普通公共许可证，直接点击Next进行下一步：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/git_0.png" alt=""></div>

<p>&emsp;&emsp;第二步，选择安装目录，没什么说的：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/git_1.png" alt=""></div>

<p>&emsp;&emsp;第三步，选择组件，根据个人需要勾选，也可以都保持默认直接点Next：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/git_2.png" alt=""></div>

<p>&emsp;&emsp;其中：<br>&emsp;&emsp;<strong>Additional icons(On the Desktop)</strong>：在桌面创建快捷方式，其实有右键菜单就够了；<br>&emsp;&emsp;<strong>Windows Explorer intergration</strong>：即右键菜单集成，由于不常用GUI，所以这里不选Git GUI Here；<br>&emsp;&emsp;<strong>Git LFS</strong>：大文件支持；<br>&emsp;&emsp;<strong>Associate .git* configuration files with the default text editor</strong>：使.git文件与默认文本编辑器关联，即用默认文本编辑器打开.sh文件；<br>&emsp;&emsp;<strong>Associate .sh files to be run with Bash</strong>：使用Git Bash关联执行.sh文件；<br>&emsp;&emsp;<strong>Use a TrueType font in all console windows</strong>：在所有命令行窗口中使用TrueType字体，推荐勾选；<br>&emsp;&emsp;<strong>Check daily for Git for Windows updates</strong>：每天检查Git更新；<br>&emsp;&emsp;第四步，开始菜单，没啥说的，不想它创建可以勾选左下角的Don’t create a Start Menu folder:</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/git_3.png" alt=""></div>

<p>&emsp;&emsp;第五步，选择Git使用的默认编辑器，这里可以选Vim、Notepad++，VS Code等，可以根据自己的喜好选择，这里保持默认:</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/git_4.png" alt=""></div>

<p>&emsp;&emsp;第六步，调整环境变量，建议保持默认，即选择第二个选项:</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/git_5.png" alt=""></div>

<p>&emsp;&emsp;其中：<br>&emsp;&emsp;<strong>Use Git from Git Bash only</strong>：只能在Git Bash中使用Git命令；<br>&emsp;&emsp;<strong>Use Git from the Windows Command Prompt</strong>：可以在Git Bash和Windows命令提示符中使用Git；<br>&emsp;&emsp;<strong>Use Git and optional Unix tools from the Windows Command Prompt</strong>：Git命令和部分Unix命令将添加到环境变量中，这将覆盖部分cmd命令，例如<code>find</code>和<code>sort</code>等；<br>&emsp;&emsp;第七步，选择HTTPS传输后端库，保持默认选项（使用OpenSSL库）即可:</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/git_6.png" alt=""></div>

<p>&emsp;&emsp;其中：<br>&emsp;&emsp;<strong>Use the OpenSSL library</strong>：使用OpenSSL库，将使用ca-bundle.crt进行服务器验证；<br>&emsp;&emsp;<strong>Use the native Windows Secure Channel library</strong>：使用Windows本地安全验证库，将使用Windows证书存储进行服务器验证，允许使用公司的CA根证书通过活动目录域服务分发；<br>&emsp;&emsp;第八步，换行符转换选择，使用默认选项（第一个）即可:</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/git_7.png" alt=""></div>

<p>&emsp;&emsp;其中：<br>&emsp;&emsp;<strong>Checkout Windows-style, commit Unix-style line endings</strong>：Git在拉取文本文件时将自动把换行符LF转换为CRLF；提交文本文件时，将自动把换行符CRLF转换为LF。如果时跨平台项目，推荐选择该选项；<br>&emsp;&emsp;<strong>Checkout as-is, commit Unix-style line endings</strong>：Git在拉取文本文件时将不做任何转换，提交文本文件时，将自动把换行符CRLF转换为LF；<br>&emsp;&emsp;<strong>Checkout as-is, commit as-is</strong>：Git在拉取文本文件和提交文本文件时将不做任何转换。<br>&emsp;&emsp;第九步，Git Bash终端配置，推荐使用默认选项，即使用MinTTY:</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/git_8.png" alt=""></div>

<p>&emsp;&emsp;其中：<br>&emsp;&emsp;<strong>Use MinTTY(hte default terminal of MSYS2)</strong>：使用MinTTY终端，窗口大小可调整，支持自由选择文本和Unicode字符集；<br>&emsp;&emsp;<strong>Use Windows’ default console window</strong>：使用windows命令提示符，滚动受限，要正确显示非ASCII字符时还需配置为支持Unicode字符集的字体，在Windows 10之前，窗口无法自由调整大小，且只能矩形框选文本。<br>&emsp;&emsp;最后一步，配置其他选项，保持默认选择即可:</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/git_9.png" alt=""></div>

<p>&emsp;&emsp;其中：<br>&emsp;&emsp;<strong>Enable file system caching</strong>：开启文件系统缓存，文件数据将被批量读取并缓存在内存中以进行某些操作，将带来显著的性能提升；<br>&emsp;&emsp;<strong>Enable Git Credential Manager</strong>：开启Git凭据管理器，为windows提供安全的Git凭据存储, 特别时对VS团队服务和Github的多因素身份验证支持；<br>&emsp;&emsp;<strong>Enable symbolic links</strong>：开启符号链接，要求有SeCreateSymbolicLink权限，已存在的仓库不受该设置影响。<br>&emsp;&emsp;之后，等待安装完成。</p>
<h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><hr>
<p>&emsp;&emsp;下载地址：<a href="https://nodejs.org/dist/v8.10.0/node-v8.10.0-x64.msi" target="_blank" rel="noopener">Node.js (8.10.0 LTS, x64)</a><br>&emsp;&emsp;安装Node.js相对简单，安装路径自己分配，选择组件时保持默认（即全部安装）即可。</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/nodejs_0.png" alt=""></div><br><div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/nodejs_1.png" alt=""></div>

<h1 id="Github账号注册和配置"><a href="#Github账号注册和配置" class="headerlink" title="Github账号注册和配置"></a>Github账号注册和配置</h1><hr>
<p>&emsp;&emsp;浏览器访问<code>https://github.com</code>，在右侧注册一个GitHub账号，在下图三个输入框中分别输入用户名、邮箱和密码，输入完成后点<code>Sign up for GitHub</code>：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_6.png" alt=""></div>

<p>&emsp;&emsp;注册成功后，登录自己的邮箱，找到Github发送的注册确认邮件，确认注册。确认邮件内容类似如下截图：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_7.png" alt=""></div>

<p>&emsp;&emsp;重新登录后，点击右上角头像左侧的“+”图标，选择<code>New repository</code>进入创建代码仓库节目界面：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_8.png" alt=""></div><br>&emsp;&emsp;在<code>Repository name</code>中填写<code>yourname.github.io</code>，这里用户名是<code>MKeyo</code>，所以填写<code>mkeyo.github.io</code>，<code>Description</code>下填写描述相关内容，不填写也可以，之后点击<code>Create repository</code>：<br><div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_9.png" alt=""></div>

<p>&emsp;&emsp;创建成功后，将看到如下界面：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_10.png" alt=""></div>

<p>&emsp;&emsp;接下来开启仓库的gh-pages功能，点击右侧<code>Settings</code>（<code>Unwatch</code>下方），打开仓库的设置界面，之后下拉页面到<code>GitHub Pages</code>标签或<code>Ctrl+F</code>搜索<code>GitHub Pages</code>，点击<code>Choose a theme</code>按钮：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_11.png" alt=""></div>

<p>&emsp;&emsp;根据自己的喜好选择一个主题，点击右侧的<code>Select theme</code>按钮应用主题：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_12.png" alt=""></div>

<p>&emsp;&emsp;点击按钮后将打开<code>index.md</code>提交页，直接下拉到页面底部点击<code>Commit changes</code>提交即可：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_13.png" alt=""></div><br>&emsp;&emsp;提交成功后在浏览器中访问代码仓库的名字URL验证是否可以访问，能正常访问说明<code>GitHub Pages</code>已经搭建成功：<br><div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_14.png" alt=""></div>

<h1 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h1><p>&emsp;&emsp;首先，在桌面或任意盘符目录下右键选择<code>Git Bash Here</code>打开Git命令窗口，也可以通过开始菜单找到<code>Git Bash</code>打开：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_0.png" alt=""></div>

<p>&emsp;&emsp;打开命令窗口后需要稍等片刻，等到窗口中出现<code>MINGW64 xxx</code>类似提示时即可进行下一步操作：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_1.png" alt=""></div>

<p>&emsp;&emsp;右键点击窗口标题，选择<code>Options</code>可自行调整命令窗口选项：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_2.png" alt=""></div>

<p>&emsp;&emsp;由于默认窗口字体比较小，这里调整下字体大小，左侧点击<code>Text</code>标签，在右侧点击<code>Font</code>右边的<code>Select</code>打开字体窗口：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_3.png" alt=""></div>

<p>&emsp;&emsp;根据自己的喜好选择字体和字体大小，点击确定按钮更改，之后点击下方的<code>Save</code>保存更改：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_4.png" alt=""></div>

<p>&emsp;&emsp;调整完成后，回到命令窗口，输入以下两条命令设置git邮箱和用户名，输入时请自行替换双引号内的内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">"youremail@xxx.com"</span></span><br><span class="line">git config --global user.name <span class="string">"yourname"</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;执行效果如下截图：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_22.png" alt=""></div>

<p>&emsp;&emsp;之后，输入<code>ssh-keygen -t rsa -C &quot;youremail&quot;</code>生成SSH密钥（<code>youremail</code>替换为你的邮箱），生成SSH密钥用于GitHub授权，避免每次提交代码都需要输入账号密码，期间会有三次询问：<br>&emsp;&emsp;1、<code>Enter file in which to save the key (/c/Users/lfeng/.ssh/id_rsa):</code> 输入存放key的路径，默认为<code>c:/Users/lfeng/.ssh/id_rsa</code>；<br>&emsp;&emsp;2、<code>Enter passphrase (empty for no passphrase):</code> 输入密码；<br>&emsp;&emsp;3、<code>Enter same passphrase again:</code> 重复上一次输入的密码；<br>&emsp;&emsp;这里按三次回车键，即key文件放在默认位置且不设置密码：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_26.png" alt=""></div>

<p>&emsp;&emsp;打开<code>c:/Users/yourname/.ssh/</code>（<code>yourname</code>为你的电脑用户名），找到<code>id_rsa.pub</code>文件并打开，复制文件里的内容：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_27.png" alt=""></div>

<p>&emsp;&emsp;回到个人主页（如果关闭了网页，则访问<code>https://github.com/yourname</code>，其中<code>yourname</code>替换为你的GitHub昵称），在GitHub个人主页中点击右上角的头像，在弹出的菜单中选择<code>Settings</code>，打开设置页面：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_23.png" alt=""></div>

<p>&emsp;&emsp;点击左侧<code>SSH and GPG Key</code>标签，在右侧页面中点击<code>New SSH Key</code>按钮：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_24.png" alt=""></div>

<p>&emsp;&emsp;输入刚刚复制的<code>id_rsa.pub</code>文件里的内容，标题任意填写，完成后点击添加即可：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_25.png" alt=""></div>

<h1 id="首次体验hexo"><a href="#首次体验hexo" class="headerlink" title="首次体验hexo"></a>首次体验hexo</h1><hr>
<p>&emsp;&emsp;自定义一个用于存放博客文件的目录，这里以<code>C:/Project</code>目录为例，在该目录下右键选择<code>Git Bash Here</code>选项打开Git命令窗口，输入<code>npm install -g hexo</code>开始全局安装hexo，安装时间可能比较长，耐心等待即可：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_5.png" alt=""></div>

<p>&emsp;&emsp;安装完成之后，继续输入<code>npm install -g hexo-cli</code>开始全局安装hexo-cli，安装期间可能会有警告出现，忽略即可：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_15.png" alt=""></div>

<p>&emsp;&emsp;继续输入<code>hexo init</code>初始化hexo：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_16.png" alt=""></div>

<p>&emsp;&emsp;之后输入<code>npm install</code>安装所需的组件，等待其安装完成后进行下一步：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_17.png" alt=""></div>

<p>&emsp;&emsp;继续输入<code>hexo g</code>生成网站文件，之后输入<code>hexo s</code>开启本地服务器：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_18.png" alt=""></div>

<p>&emsp;&emsp;在浏览器中打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>，将会看到搭建好的博客页面：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_19.png" alt=""></div>

<h1 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h1><p>&emsp;&emsp;打开目录下的<code>_config.yml</code>，编辑其中的配置：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_20.png" alt=""></div>

<p>&emsp;&emsp;首先修改<code>Site</code>网站部分的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line"># 网站标题</span><br><span class="line">title: mkeyo</span><br><span class="line"># 网站副标题</span><br><span class="line">subtitle:</span><br><span class="line"># 网站描述</span><br><span class="line">description:</span><br><span class="line"># 关键字</span><br><span class="line">keywords:</span><br><span class="line"># 您的名字</span><br><span class="line">author: MKeyo</span><br><span class="line"># 网站使用的语言，默认为英语，设置简体汉语zh-Hans</span><br><span class="line">language: zh-Hans</span><br><span class="line"># 网站时区。Hexo 默认使用电脑的时区。</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;接下来是<code>Site</code>网站部分的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line"># 网址，如果网站存放在子目录中，例如：http://yoursite.com/blog，则把url设为http://yoursite.com/blog并把root设为 /blog/。</span><br><span class="line">url: https://mkeyo.github.io</span><br><span class="line"># 网站根目录</span><br><span class="line">root: /</span><br><span class="line"># 文章的永久链接格式</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line"># 永久链接中各部分的默认值</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;最后是<code>Deployment</code>部署部分的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  #类型，这里填git</span><br><span class="line">  type: git</span><br><span class="line">  # 代码仓库地址，格式为：git@github.com:yourname/repositoryname.git，其中yourname为你的GitHub昵称，repositoryname为代码仓库名称</span><br><span class="line">  repo: git@github.com:MKeyo/mkeyo.github.io.git</span><br><span class="line">  # 分支，这里填master，即主干</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;其他部分配置这里不做修改，保持默认即可，配置详细说明可以参考<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener"><strong>官方文档</strong></a>，配置完成后保存文件。</p>
<h1 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h1><p>&emsp;&emsp;在存放博客文件的目录下打开Git命令窗口，输入<code>npm install hexo-deployer-git --save</code>安装hexo发布到git组件，等待安装完成后进行下一步：</p>
<div align="center"><img src="../images/2018/Build-personal-blog-with-github-and-hexo/op_21.png" alt=""></div>
]]></content>
      
        <categories>
            
            <category> github </category>
            
        </categories>
        
        
        <tags>
            
            <tag> blog </tag>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Behaviac简单介绍]]></title>
      <url>/blog/2018/Simple-introduction-of-behaviac.html</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;behaviac是游戏AI的开发框架组件，也是游戏原型的快速设计工具，支持全平台，适用于客户端和服务器，详细可查看： <a href="http://www.behaviac.com/language/zh/overview/" target="_blank" rel="noopener"><strong>behaviac概述</strong></a><br>&emsp;&emsp;exe安装包下载地址： <a href="https://github.com/Tencent/behaviac/releases/download/3.6.39/BehaviacSetup_3.6.39.exe" target="_blank" rel="noopener"><strong>3.6.39版</strong></a><br>&emsp;&emsp;behaviac项目源代码： <a href="https://github.com/Tencent/behaviac/archive/3.6.39.zip" target="_blank" rel="noopener"><strong>3.6.39版</strong></a><br>&emsp;&emsp;以下内容中大部分来自behaviac官方文档，详细可查看： <a href="http://www.behaviac.com/language/zh/category/%E6%96%87%E6%A1%A3/" target="_blank" rel="noopener"><strong>文档页面</strong></a><br><a id="more"></a></p>
<h2 id="工作原理和流程"><a href="#工作原理和流程" class="headerlink" title="工作原理和流程"></a>工作原理和流程</h2><p>&emsp;&emsp;behaviac整套组件分为编辑器和运行时库，编辑器是独立运行的程序，运行时库需要整合到自己的项目中，各模块的关系如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/1.png" alt="各模块关系"></div><br>&emsp;&emsp;其中：工作区用于管理整个项目，包括类型信息和行为树文件等；类型信息包括Agent类及其成员属性、成员方法和实例等，以及枚举和结构体类型；行为树描述了指定的Agent类型的行为，利用各种节点和类型信息来创建行为树；运行时端根据编辑器导出的类型信息，执行导出的行为树。整个组件工作流程：<br><div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/2.png" alt="组件工作流程"></div>

<p>&emsp;&emsp;其中，&quot;胶水&quot;代码是指编辑器自动生成的代码文件，用于注册类型信息，可用于程序端执行时通过名字或ID调用类的成员属性或方法。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>&emsp;&emsp;点击下载示例项目文件：<a href="../attachments/BehaviacTest.zip"><strong>示例下载</strong></a><br>&emsp;&emsp;以下内容中的截图大部分来自示例项目，自行解压缩之后使用编辑器打开HelloTest文件夹下的HelloTest.workspace.xml即可。</p>
<h2 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h2><p>&emsp;&emsp;通过菜单项&quot;视图&quot;-&gt;&quot;类型信息&quot;（或快捷键<code>Ctrl+M</code>），打开类型信息面板，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/3.png" alt="类型信息面板"></div>

<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>&emsp;&emsp;类型分为三种：Agent、Struct和Enum，在新加一个类型的时候，可以相应的选择，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/4.png" alt="类型"></div><br>&emsp;&emsp;在类型信息面板左侧的&quot;类型列表&quot;中选择所要编辑的Agent子类，在右侧的&quot;类型&quot;属性框中，可以修改相关的参数，如下图所示：<br><div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/5.png" alt="类型属性"></div>

<p>&emsp;&emsp;&quot;类型&quot;框中的各个参数说明如下：<br>&emsp;&emsp;<strong>生成代码</strong>：表示该类型是否需要在点击右下方的&quot;应用&quot;按钮时，生成源代码文件；<br>&emsp;&emsp;<strong>名称</strong>：该类型的名字，跟C++/C#的变量命名要求一致，不能输入非法字符；<br>&emsp;&emsp;<strong>命名空间</strong>：该类型的命名空间，跟C++/C#的命名空间一致；<br>&emsp;&emsp;<strong>基类</strong>：该类型的基类；<br>&emsp;&emsp;<strong>引用类型</strong>：该类型是否为引用类型，主要提供给结构体类型使用。若是引用类型，则表示在编辑器中使用时，只能作为引用或指针使用，不能展开配置其成员属性。Agent子类都是引用类型，结构体类型可以选择为引用或非引用类型，枚举类型都是非引用类型；<br>&emsp;&emsp;<strong>生成位置</strong>：一般不用设置，默认会统一使用工作区中配置的&quot;代码生成位置&quot;。但如果设置了该参数，表示当前类型会生成在指定的目录；<br>&emsp;&emsp;<strong>显示名</strong>：用于在编辑器中显示该类型的名字，可以用中文；<br>&emsp;&emsp;<strong>描述</strong>：用于在编辑器中显示该类型的描述内容，可以用中文。<br>&emsp;&emsp;右上方的按钮说明如下：<br>&emsp;&emsp;<strong>新增</strong>：用于添加一个新的类型；<br>&emsp;&emsp;<strong>删除</strong>：用于删除选中的类型；<br>&emsp;&emsp;<strong>预览原型代码</strong>：用于预览生成的代码内容。如果没有勾选上述&quot;类型&quot;框中的&quot;生成代码&quot;选项，可以点击该按钮打开原型代码文件后，复制相关的内容到自己的代码中；<br>&emsp;&emsp;<strong>设置头文件</strong>：在编辑器自动生成的代码中，可能需要包含项目中的头文件，这时就需要点击该按钮，弹出&quot;C++导出设置&quot;窗口添加需要的头文件。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>&emsp;&emsp;在类型信息面板中部位置的&quot;实例名称&quot;列表中，列举了当前选中的Agent子类的所有全局实例名。在其右侧的&quot;新增&quot;按钮用于添加一个实例名，&quot;删除&quot;按钮用于删除当前选中的实例名，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/6.png" alt="实例"></div>

<p>&emsp;&emsp;实例的详细使用说明可查看： <a href="http://www.behaviac.com/tutorial_3_agent_instance/" target="_blank" rel="noopener"><strong>教程三：Agent实例</strong></a></p>
<h3 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h3><p>&emsp;&emsp;在类型信息面板中下部位置的&quot;成员类型&quot;分为Property（成员属性）、Method（成员方法）和Task（任务，用于定义子树调用的接口原型）。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>&emsp;&emsp;成员列表&quot;根据上面选择的&quot;成员类型&quot;，列出了所有的成员；&quot;筛选字符&quot;用于列举自己指定字符的所有成员，即快速检索自己所需的成员，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/7.png" alt="属性列表"></div>

<p>&emsp;&emsp;选择某个属性后，即可在下方&quot;属性&quot;框中查看该属性的各个参数：<br>&emsp;&emsp;<strong>名字</strong>：该属性的名字，跟C++/C#的变量命名要求一致，不能输入非法字符；<br>&emsp;&emsp;<strong>类型</strong>：该属性的类型。如果勾选了后面的&quot;数组？&quot;，则表示该类型为数组类型；<br>&emsp;&emsp;<strong>公开</strong>：该属性是否为public，跟C++/C#中的概念一致；<br>&emsp;&emsp;<strong>静态</strong>：该属性是否为static，跟C++/C#中的概念一致；<br>&emsp;&emsp;<strong>只读</strong>：该属性是否只读。如果为只读，那么在赋值节点中，不能作为左值被赋值，只能读取该值；<br>&emsp;&emsp;<strong>局部变量</strong>：表示该属性是否为局部变量。如果是局部变量，那么只在当前打开的行为树中使用，否则，是普通的成员属性，隶属于当前Agent子类，可用于任何行为树；<br>&emsp;&emsp;<strong>默认值</strong>：该属性的默认初始值，会自动生成在类型的构造函数中；<br>&emsp;&emsp;<strong>显示名</strong>：用于在编辑器中显示该属性的名字，可以用中文；<br>&emsp;&emsp;<strong>描述</strong>：用于在编辑器中显示该属性的描述内容，可以用中文。<br>&emsp;&emsp;右侧的&quot;新增&quot;按钮用于添加新的属性，&quot;删除&quot;按钮用于删除选中的属性，&quot;往上&quot;和&quot;往下&quot;按钮用于调整选中属性的相对位置。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>&emsp;&emsp;在类型信息面板中，将&quot;成员类型&quot;选择为&quot;Method&quot;，则在&quot;成员列表&quot;中列出了所有的成员方法，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/8.png" alt="方法列表"></div>

<p>&emsp;&emsp;选择某个方法后，即可在下方&quot;属性&quot;框中查看该方法的各个参数：<br>&emsp;&emsp;<strong>名字</strong>：该方法的名字，跟C++/C#的变量命名要求一致，不能输入非法字符；<br>&emsp;&emsp;<strong>返回值类型</strong>：该方法的返回值类型。如果勾选了后面的&quot;数组？&quot;，则表示该类型为数组类型；<br>&emsp;&emsp;<strong>公开</strong>：该方法是否为public，跟C++/C#中的概念一致；<br>&emsp;&emsp;<strong>静态</strong>：该方法是否为static，跟C++/C#中的概念一致；<br>&emsp;&emsp;<strong>显示名</strong>：用于在编辑器中显示该方法的名字，可以用中文；<br>&emsp;&emsp;<strong>描述</strong>：用于在编辑器中显示该方法的描述内容，可以用中文；<br>&emsp;&emsp;<strong>参数</strong>：该方法的参数列表，可以添加和删除。</p>
<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>&emsp;&emsp;在类型信息面板中，将&quot;成员类型&quot;选择为&quot;Task&quot;，则在&quot;成员列表&quot;中列出了所有的任务，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/9.png" alt="任务列表"></div>

<p>&emsp;&emsp;任务的编辑跟成员方法的编辑相同，任务只是定义了一个接口原型，用于事件的参数传递。</p>
<h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><p>&emsp;&emsp;编辑类型信息的过程中，不要忘记点击右下方的&quot;应用&quot;按钮，保存和生成类型信息。</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>&emsp;&emsp;behaviac有以下节点类型：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/10.png" alt="节点类型"></div>

<p>&emsp;&emsp;接下来以以下几个行为树为例，说明各个节点的功能：<br>&emsp;&emsp;<code>1_Attach</code>&emsp;附件类节点<br>&emsp;&emsp;<code>2_Condition</code>&emsp;条件类节点<br>&emsp;&emsp;<code>3_Action</code>&emsp;动作类节点<br>&emsp;&emsp;<code>4_Combine</code>&emsp;组合类节点<br>&emsp;&emsp;<code>5_Combine_2</code>&emsp;组合类节点（等待信号和子树）<br>&emsp;&emsp;<code>6_Adorner</code>&emsp;装饰器类节点<br>&emsp;&emsp;<code>7_StateMachine</code>&emsp;状态机类节点</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/11.png" alt="行为树列表"></div>

<h3 id="附件类节点"><a href="#附件类节点" class="headerlink" title="附件类节点"></a>附件类节点</h3><p>&emsp;&emsp;附件类节点包含前置和后置节点，可以添加到任何一个节点作为前置和后置。前置往往是作为前提条件来使用，而后置往往是当节点结束的时候施加效果，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/12.png" alt="附件类节点"></div>

<h3 id="条件类节点"><a href="#条件类节点" class="headerlink" title="条件类节点"></a>条件类节点</h3><p>&emsp;&emsp;条件节点对左右参数进行比较，根据比较结果返回成功或失败，但永远不会返回正在执行（Running）。通常左参数是Agent的某个属性或某个有返回值的方法，用户可以从下拉列表里选择，右参数是相应类型的常数、Agent的某个属性或某个有返回值的方法，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/13.png" alt="条件类节点"></div>

<p>&emsp;&emsp;与节点接受两个以上的条件子节点，执行逻辑&quot;与（&amp;&amp;）&quot;操作，如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/14.png" alt="条件与节点"></div>

<p>&emsp;&emsp;或节点接受两个以上的条件子节点，执行逻辑&quot;或（||）&quot;操作，如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/15.png" alt="条件或节点"></div>

<h3 id="动作类节点"><a href="#动作类节点" class="headerlink" title="动作类节点"></a>动作类节点</h3><h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><p>&emsp;&emsp;等待节点在指定的数值内（单位根据自己的使用场景来定）持续保持为运行（Running）状态，数值到达之后则返回成功，如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/16.png" alt="等待节点"></div>

<p>&emsp;&emsp;需要配置&quot;持续时间&quot;，可以是常数、属性或方法的返回值（支持double和int类型），如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/17.png" alt="等待节点配置"></div>

<p>&emsp;&emsp;在工作区配置窗口中，可以勾选左下角的&quot;使用整数值&quot;来表示是否使用整数值，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/18.png" alt="等待节点配置"></div>

<p>&emsp;&emsp;等待节点的更新逻辑如下，需要注意的是，使用等待节点需在游戏更新代码中调用SetIntValueSinceStartup或SetDoubleValueSinceStartup设置总时间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">EBTStatus WaitTask::update(Agent* pAgent, EBTStatus childStatus) </span><br><span class="line">&#123;</span><br><span class="line">    BEHAVIAC_UNUSED_VAR(pAgent);</span><br><span class="line">    BEHAVIAC_UNUSED_VAR(childStatus);</span><br><span class="line">    <span class="keyword">bool</span> bUseIntValue = Workspace::GetInstance()-&gt;GetUseIntValue();</span><br><span class="line">    <span class="keyword">if</span> (bUseIntValue) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> time = Workspace::GetInstance()-&gt;GetIntValueSinceStartup();</span><br><span class="line">        <span class="keyword">if</span> (time - <span class="keyword">this</span>-&gt;m_intStart &gt;= <span class="keyword">this</span>-&gt;m_intTime) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> BT_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> time = Workspace::GetInstance()-&gt;GetDoubleValueSinceStartup();</span><br><span class="line">        <span class="keyword">if</span> (time - <span class="keyword">this</span>-&gt;m_start &gt;= <span class="keyword">this</span>-&gt;m_time) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> BT_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> BT_RUNNING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h4><p>&emsp;&emsp;动作节点是比较常用的节点，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/19.png" alt="动作节点"></div>

<p>&emsp;&emsp;动作节点通常对应Agent的某个方法，可以从下拉列表里为其选择方法：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/20.png" alt="动作节点属性"></div>

<p>&emsp;&emsp;在设置其方法后，需进一步设置其&quot;决定状态的选项&quot;或&quot;决定状态的函数&quot;，如上图所示。如果没有正确配置，则视为错误不能被导出。<br>&emsp;&emsp;<strong>决定状态的选项</strong>：不管动作的方法的返回值是什么，都强制返回设定的EBTStatus值（即Success、Failure或Running）。<br>&emsp;&emsp;<strong>决定状态的函数</strong>：将动作的方法的返回值从不是EBTStatus类型，转换为执行行为树所需要的EBTStatus值（即Success、Failure或Running）。<br>&emsp;&emsp;有三种设置来决定每次执行动作节点后的状态（Success、Failure或Running）：<br>&emsp;&emsp;1、如果动作节点的方法返回EBTStatus值，那么该值就直接作为动作节点的状态，&quot;决定状态的选项&quot;和&quot;决定状态的函数&quot;将被禁用无需设置。<br>&emsp;&emsp;2、否则，需要设置&quot;决定状态的选项&quot;：当选择Invalid值时，表明需要进一步设置&quot;决定状态的函数&quot;，否则禁用&quot;决定状态的函数&quot;项，并直接使用&quot;决定状态的选项&quot;所选择的值（Success、Failure或Running），表示该方法执行完毕后，动作节点将返回这个设置的值。<br>&emsp;&emsp;3、在&quot;决定状态的函数&quot;项中选择的函数，其返回值必然是EBTStatus，作为动作节点的状态。该函数只有一个或者没有参数，当动作节点的方法无返回值时，该函数没有参数，当动作节点的方法有返回值时，该函数唯一参数的类型为动作节点方法的返回值类型。也即：<br>&emsp;&emsp;当方法的原型是void Method(…)的时候，&quot;决定状态的函数&quot;的原型为：EBTStatus StatusFunctor()。<br>&emsp;&emsp;当方法的原型是ReturnType Method(…)的时候，&quot;决定状态的函数&quot;的原型为：EBTStatus StatusFunctor(ReturnType param)。</p>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>&emsp;&emsp;赋值节点实现了赋值的操作，可以把右边的值赋值给左侧的参数，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/21.png" alt="赋值节点"></div>

<p>&emsp;&emsp;其中，左参数是某个Agent实例的属性，右参数可以是常数、Agent实例的属性或者方法调用的返回值，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/22.png" alt="赋值节点属性"></div>

<p>&emsp;&emsp;当属性&#39;类型转换&#39;没有选中的时候，赋值节点只允许相同的类型进行赋值，也就是说右参数的下拉列表中仅列出与左参数相同类型的参数；而&#39;类型转换&#39;选中的时候，赋值节点允许较为宽松的类型。分为以下两种情况：<br>&emsp;&emsp;1、当左参数是数据类型（int，short，byte，float等）的时候，右参数也将是数据类型，不需要完全一致。<br>&emsp;&emsp;2、当左参数是指针类型（对于C#是引用类型）的时候，右参数将是左参数类型的同类或子类。</p>
<h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>&emsp;&emsp;计算节点对常数、属性或函数的返回值做加减乘除的运算，把结果赋值给某个属性，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/23.png" alt="计算节点"></div>

<p>&emsp;&emsp;其中，左参数是某个Agent实例的属性，参数1和参数2可以是常数、Agent实例的属性或者方法调用的返回值，操作符可以是&quot;+, -, *, /&quot;，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/24.png" alt="计算节点属性"></div>

<p>&emsp;&emsp;需要注意的是，这些操作的&quot;粒度&quot;过小，大量这种小粒度的操作可能对性能造成影响。复杂的计算建议使用动作节点调用相应的函数实现修改或计算。</p>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>&emsp;&emsp;结束节点可以使用于行为树执行过程中的强制返回，即终止该行为树的全部执行，整个行为树直接返回当前结束节点所配置的&quot;结束状态&quot;值，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/25.png" alt="结束节点"></div>

<p>&emsp;&emsp;在上图中，当执行到结束节点时，行为树直接返回Success，不再执行下面ID为10的动作节点。<br>&emsp;&emsp;可以为结束节点配置&quot;结束状态&quot;属性，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/26.png" alt="结束节点属性"></div>

<p>&emsp;&emsp;上面的&quot;结束状态&quot;可以是一个常量，也可以是成员属性或方法的返回值，表示行为树执行到结束节点时，强制返回&quot;结束状态&quot;所配置的当前值。<br>&emsp;&emsp;注意：只有&quot;结束状态&quot;的当前值是Success或Failure时，行为树才会结束并返回该值；为Invalid或Running时，该结束节点不起作用，行为树接着执行。<br>&emsp;&emsp;此外，还有一个属性&quot;结束外层树&quot;，该属性用于表示在子树中的结束节点返回时，是否需要返回该子树所在的父树。</p>
<h4 id="空操作"><a href="#空操作" class="headerlink" title="空操作"></a>空操作</h4><p>&emsp;&emsp;空操作也就是什么都不做，如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/27.png" alt="空操作节点"></div>

<h4 id="等待帧数"><a href="#等待帧数" class="headerlink" title="等待帧数"></a>等待帧数</h4><p>&emsp;&emsp;等待帧数节点顾名思义就是等待指定的帧数后返回成功，如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/28.png" alt="等待帧数节点"></div>

<p>&emsp;&emsp;等待帧数节点的更新逻辑如下，需要在游戏更函数中调用SetFrameSinceStartup设置帧数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">EBTStatus WaitTask::update(Agent* pAgent, EBTStatus childStatus) </span><br><span class="line">&#123;</span><br><span class="line">    BEHAVIAC_UNUSED_VAR(pAgent);</span><br><span class="line">    BEHAVIAC_UNUSED_VAR(childStatus);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> bUseIntValue = Workspace::GetInstance()-&gt;GetUseIntValue();</span><br><span class="line">    <span class="keyword">if</span> (bUseIntValue) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> time = Workspace::GetInstance()-&gt;GetIntValueSinceStartup();</span><br><span class="line">        <span class="keyword">if</span> (time - <span class="keyword">this</span>-&gt;m_intStart &gt;= <span class="keyword">this</span>-&gt;m_intTime) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> BT_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> time = Workspace::GetInstance()-&gt;GetDoubleValueSinceStartup();</span><br><span class="line">        <span class="keyword">if</span> (time - <span class="keyword">this</span>-&gt;m_start &gt;= <span class="keyword">this</span>-&gt;m_time) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> BT_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> BT_RUNNING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合类节点"><a href="#组合类节点" class="headerlink" title="组合类节点"></a>组合类节点</h3><h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>&emsp;&emsp;并行节点在逻辑上是&quot;同时&quot;并行的执行所有子节点（但实际也是从上往下依次执行），然后根据所有子节点的状态决定本身的状态，如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/29.png" alt="并行节点"></div>

<p>&emsp;&emsp;并行节点有几个重要属性可以配置，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/30.png" alt="并行节点属性"></div>

<p>&emsp;&emsp;<strong>失败条件</strong>：决定并行节点在什么条件下是失败的；<br>&emsp;&emsp;<strong>成功条件</strong>：决定并行节点在什么条件下是成功的；<br>&emsp;&emsp;<strong>子节点结束继续条件</strong>：子节点结束后是重新再循环执行，还是结束后不再执行；<br>&emsp;&emsp;<strong>退出行为</strong>：当并行节点的成功或失败条件满足并返回成功或失败后，是否需要终止掉其他还在运行的子节点。<br>&emsp;&emsp;当子节点执行状态既不满足失败条件，也不满足成功条件，且无Running状态子节点时，并行节点将直接返回Failure。</p>
<h4 id="子树"><a href="#子树" class="headerlink" title="子树"></a>子树</h4><p>&emsp;&emsp;通过子树节点，一个行为树可以作为另一个行为树的子树。作为子树的那个行为树被&quot;调用&quot;。如同一个动作节点一样，子树节点根据子树的执行结果也会返回执行结果（成功、失败或运行。），其父节点按照自己的控制逻辑来控制接下来的运行。</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/31.png" alt="子树节点"></div>

<p>&emsp;&emsp;子树节点属性如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/32.png" alt="子树节点属性"></div>

<p>&emsp;&emsp;引用文件名，作为被调用的子树的行为树的相对路径。该属性不允许为空，需要是有效的路径。没有提供有效路径会导致报错并且该树不允许被导出。引用文件名可以是const常量，可以是变量(其值是行为树的相对路径)，或函数（其返回值需要是字符串，是行为树的相对路径）。<br>&emsp;&emsp;任务，如果子树的根节点是任务节点，这里会出现该任务，并且允许提供参数。如在最上的图中，8号节点travel(x, ax)，4号节点travel(ay, y)。如果子树的根节点不是任务节点，或者引用文件名不是常量，任务属性就是空的。</p>
<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>&emsp;&emsp;一个行为树可以&quot;调用&quot;自己，这么做的时候形成递归，形成递归的时候需要注意不要造成死循环，这可以通过变量的使用来避免。<br>&emsp;&emsp;如下图所示，利用<code>testVar_0</code>来避免死循环：第一次进入的时候<code>testVar_0 == 0</code>，所以可以执行下面的序列，先把<code>testVar_0</code>赋值为1，那么在下面的递归重入的时候由于<code>testVar_0 == 1</code>，所以<code>testVar_0 == 0</code>的条件不满足，所以下面的序列不会进入从而避免了死循环。</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/33.png" alt="递归避免死循环"></div>

<h5 id="添加子树节点"><a href="#添加子树节点" class="headerlink" title="添加子树节点"></a>添加子树节点</h5><p>&emsp;&emsp;在编辑器中，可以通过鼠标拖拽一棵行为树到另一棵行为树中生成子树节点，被拖拽的行为树的路径被设置到引用文件名。需要指出的是，并非任意一个行为树都可以作为另外一个行为树的子树。作为子树的行为树的Agent类型需要是&quot;父树&quot;的Agent类型的子类或同类。也可以像添加其他节点那样，在节点列表中选取子树，拖拽其到相应的位置，然后配置引用文件名或任务。<br>&emsp;&emsp;如果手工配置的子树的路径是空的，或无效的则会报错，该树不允许被导出。如果配置的是变量或函数，编辑器中无法知道其是否有效，只有在运行时发现值无效才会报运行时错误。</p>
<h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><p>&emsp;&emsp;选择节点以给定的顺序依次调用其子节点，直到其中一个成功返回，那么该节点也返回成功。如果所有的子节点都失败，那么该节点也失败。</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/34.png" alt="选择节点"></div>

<p>&emsp;&emsp;选择节点可以添加&#39;中断条件&#39;作为终止执行的条件。下图中红框中的箭头就是可选的&#39;中断条件&#39;。该&#39;中断条件&#39;在每处理下一个子节点的时候被检查，当为true时，则不再继续，返回失败（Failure）。</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/35.png" alt="选择节点"></div>

<h4 id="概率选择"><a href="#概率选择" class="headerlink" title="概率选择"></a>概率选择</h4><p>&emsp;&emsp;类似选择节点，概率选择节点也是从子节点中选择执行一个，但不像选择节点每次都是按照排列的先后顺序选择，概率选择节点每次选择的时候根据子节点的&quot;概率权值&quot;进行选择，权值越大，被选到的机会越大，权值为0，则其分支不会被执行，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/36.png" alt="概率选择节点"></div>

<p>&emsp;&emsp;概率选择节点根据概率&quot;直接&quot;选择并执行某个子节点，无论其返回成功还是失败，概率选择节点也将返回同样的结果。如果该子节点返回失败，概率选择也返回失败，它不会像选择节点那样会继续执行接下来的子节点。<br>&emsp;&emsp;概率选择节点有随机数生成器可以配置，该随机数生成器是一个返回值为0.0到1.0之间的float类型的函数，一般设为空即可，表示采用系统的缺省实现，也可以使用自己提供的函数。如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/37.png" alt="概率选择节点属性"></div>

<p>&emsp;&emsp;概率选择节点的子节点只能是权值的子节点，在添加子节点时，该权值节点会被系统自动添加。所有权值子节点的相加之和不需要是100，执行时会进行归一化操作，子节点的概率是该子节点的权值/总和。<br>&emsp;&emsp;概率选择节点的选择算法是基于概率区间的，比如上图中的2个子节点的权值都为1，归一化后的概率为0.5，那么对应的概率区间分别是[0.0, 0.5)、[0.5, 1)。概率选择节点的随机数生成器随机产生一个[0.0, 1.0)之间的随机数，看这个随机数落在哪个区间，则执行第几个子节点。例如，随机数为0.45，落在第一个区间[0.0, 0.5)，则选择执行第一个子节点。</p>
<h4 id="随机选择"><a href="#随机选择" class="headerlink" title="随机选择"></a>随机选择</h4><p>&emsp;&emsp;类似选择节点，随机选择节点也是从子节点中选择执行一个，但不像选择节点每次都是按照排列的先后顺序选择，随机选择节点每次选择的时候随机的决定执行顺序，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/38.png" alt="随机选择节点"></div>

<p>&emsp;&emsp;随机选择节点有随机数生成器可以配置，该随机数生成器是一个返回值为0.0到1.0之间的float类型的函数，一般设为空即可，表示采用系统的缺省实现，也可以使用自己提供的函数。如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/39.png" alt="随机选择节点属性"></div>

<h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4><p>&emsp;&emsp;序列以给定的顺序依次执行其子节点，直到所有子节点成功返回，该节点也返回成功。只要其中某个子节点失败，那么该节点也失败。如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/40.png" alt="序列节点"></div>

<p>&emsp;&emsp;序列节点不仅可以管理&#39;动作&#39;子节点，也可以管理&#39;条件&#39;子节点，如下图（FirstBT），由于假节点必定返回false，即失败，那么后面的Print(&quot;Failure&quot;)将不再执行：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/41.png" alt="序列节点属性"></div>

<p>&emsp;&emsp;序列节点可以添加&#39;中断条件&#39;作为终止执行的条件。上图中序列节点右上角的箭头就是可选的&#39;中断条件&#39;，该&#39;中断条件&#39;在每处理下一个子节点的时候被检查，当为true时，则不再继续，返回失败（Failure）。</p>
<h4 id="随机序列"><a href="#随机序列" class="headerlink" title="随机序列"></a>随机序列</h4><p>&emsp;&emsp;类似序列节点，随机序列节点也是从子节点中顺序执行，但不像序列节点每次都是按照排列的先后顺序，随机序列节点每次执行子节点时随机的决定其执行顺序，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/42.png" alt="随机序列节点"></div>

<p>&emsp;&emsp;与随机选择节点相同的是，随机序列节点也有随机数生成器可以配置，该随机数生成器是一个返回值为0.0到1.0之间的float类型的函数，一般设为空即可，表示采用系统的缺省实现，也可以使用自己提供的函数。如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/43.png" alt="随机序列节点属性"></div>

<h4 id="条件执行"><a href="#条件执行" class="headerlink" title="条件执行"></a>条件执行</h4><p>&emsp;&emsp;条件执行节点与IfElse流程相似，其必须要有3个子节点，第一个子节点是条件分支，第二个子节点是&quot;真时执行&quot;分支，第三个子节点是&quot;假时执行&quot;分支。如果条件为真，那么执行&quot;真时执行&quot;分支；否则，执行&quot;假时执行&quot;分支。如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/44.png" alt="条件执行节点"></div>

<p>&emsp;&emsp;如果不使用条件执行节点，也可以用序列和选择节点来实现相同的功能，只不过没有条件执行节点简洁。另外，条件执行节点的&quot;条件&quot;分支，还可以挂上动作节点甚至是一棵子树。比如挂上动作节点时，如果该动作节点返回Running，则条件执行节点也返回Running，并且该条件一直持续执行，直到动作节点返回Success或Failure，则继续相应的执行&quot;真时执行&quot;或&quot;假时执行&quot;分支。</p>
<h4 id="等待信号"><a href="#等待信号" class="headerlink" title="等待信号"></a>等待信号</h4><p>&emsp;&emsp;等待信号节点模拟了等待某个条件的&quot;阻塞&quot;过程。等待信号节点返回Running，直到它上面附加的条件是true的时候：<br>&emsp;&emsp;1、如果有子节点，则执行其子节点，并当子节点结束时，返回该子节点的返回值；<br>&emsp;&emsp;2、如果没有子节点，则直接返回成功。<br>&emsp;&emsp;在下图中，等待信号节点在<code>m_bFlag</code>为true之前一直返回running，当<code>m_bFlag</code>为true时，结束阻塞，执行之后的<code>m_nVal=11</code>赋值节点：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/45.png" alt="等待信号节点"></div>

<p>&emsp;&emsp;等待信号节点还可以附加子节点，如下图，在这种情况下，<code>testVar_0</code>为0时先执行<code>testVar_1 =1</code>赋值节点，之后执行后续的节点：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/46.png" alt="附加子节点的等待信号节点"></div>

<h4 id="选择监测"><a href="#选择监测" class="headerlink" title="选择监测"></a>选择监测</h4><p>&emsp;&emsp;选择监测节点和监测分支节点作为对传统行为树的扩展，可以很自然的处理事件和状态的改变，类似于程序语言中的&quot;switch…case&quot;语句，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/47.png" alt="选择监测节点"></div>

<p>&emsp;&emsp;需要注意以下几点：<br>&emsp;&emsp;1、选择监测和监测分支节点只能配对使用，即选择监测节点只能添加监测分支节点作为它的子节点，监测分支节点也只能作为选择监测节点的子节点被添加；<br>&emsp;&emsp;2、监测分支节点有条件分支子树和动作分支子树。只有条件分支子树返回成功的时候，动作分支子树才能够被执行；<br>&emsp;&emsp;3、选择监测节点是一个动态的选择节点，与选择节点相同的是，它选择第一个返回成功的子节点，但不同的是，它不是只选择一次，而是每次执行时都对其子节点重新评估后再进行选择；<br>&emsp;&emsp;4、选择检测节点的实现很像并行节点，每帧都要重新执行所有的子树，大量使用的时候请注意其性能。<br>&emsp;&emsp;默认情况下，上一次得到执行的动作分支，如果在下一次其条件分支也返回成功，那么这个动作分支会继续执行上次返回正在运行的节点。例如，假设上图中上一次执行行为树的时候，ID为28的条件节点返回成功，并且已经执行到ID为30的动作节点（31节点返回成功，30节点返回running），那么，当下一次执行该选择检测节点时，如果发现ID为28的条件节点还是返回成功，ID为30的动作节点就会直接得到执行，而不是先执行ID为31的动作节点。<br>&emsp;&emsp;但有的时候，可能需要在条件分支再次得到满足时，其动作分支需要重新执行，而不是默认情况下的从上次返回正在执行的节点继续执行。例如，对于上面的例子，当ID为28的条件节点再次返回成功时，需要重新执行其动作分支，即重新开始执行ID为31的动作节点，这时候，需要勾选上选择检测节点的属性&quot;重置子节点&quot;，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/48.png" alt="选择监测节点属性"></div>

<p>&emsp;&emsp;另外，执行行为树的过程中，当状态、条件发生变化或发生事件时如何响应或打断当前的执行是个重要的问题。<br>&emsp;&emsp;目前behaviac组件支持三种方式来处理状态变化或事件发生：并行节点、选择监测节点、事件附件等。简而言之，并行和选择监测节点的工作方式是采用&quot;轮询&quot;的方式，每次执行时需要重新评估所有子节点，而不是像其他节点会保留上一次正在执行的子节点以便在下一次执行时继续执行。事件附件是在游戏逻辑（程序端）发出事件时，才按需得到响应。</p>
<h4 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h4><p>&emsp;&emsp;任务节点用于描述一个接口，该接口的入口参数为当前的行为树提供了局部变量，这些局部变量可以根据需要用于该行为树所有子节点，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/49.png" alt="任务节点"></div>

<p>&emsp;&emsp;注意，任务节点只能作为行为树的第一个子节点存在，在任务节点上可以添加其他子节点。<br>&emsp;&emsp;在任务节点的任务属性中需要选择在类型信息面板中创建的事件，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/50.png" alt="任务节点属性"></div>

<p>&emsp;&emsp;带有任务节点的行为树主要用于事件的处理，事件则主要用于在游戏逻辑发出事件时，得到响应后打断当前正在执行的行为树，并切换到所设置的另一个行为树。以<code>4_Combine_Task</code>和<code>5_Combine_2</code>为例，操作步骤如下：<br>&emsp;&emsp;1、首先为FirstAgent添加一个任务<code>event_task</code>，接受一个int参数nVal：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/51.png" alt="添加任务属性"></div>

<p>&emsp;&emsp;2、新建一个任务行为树<code>4_Combine_Task</code>，添加任务节点，在属性框中选择<code>event_task</code>任务，之后添加一系列的节点：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/52.png" alt="选任务行为树"></div>

<p>&emsp;&emsp;3、新建一个用于模拟主逻辑的行为树<code>5_Combine_2</code>，拖动<code>4_Combine_Task</code>行为树到<code>5_Combine_2</code>的第一个序列节点上，这样该序列节点就有了一个事件的附件：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/53.png" alt="主行为树"></div>

<p>&emsp;&emsp;4、之后为该事件设置参数：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/54.png" alt="为事件设置参数"></div>

<p>&emsp;&emsp;其中，&quot;触发一次&quot;表示该事件是否只触发一次就不再起作用。&quot;触发模式&quot;控制该事件触发后对当前行为树的影响以及被触发的子树结束时应该如何恢复，有转移和返回两个选项：<br>&emsp;&emsp;转移：当子树结束时，当前行为树被中断和重置，该子树将被设置为当前行为树。<br>&emsp;&emsp;返回：当子树结束时，返回控制到之前打断的地方继续执行。当前行为树直接&quot;压&quot;到执行堆栈上而不被中断和重置，该子树被设置为当前行为树，当该子树结束时，原本的那棵行为树从执行堆栈上&quot;弹出&quot;，并从当初的节点恢复执行。<br>&emsp;&emsp;5、最后在代码中通过如下代码将事件<code>event_task</code>发出，并指定所需参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_pFirstAgent-&gt;FireEvent(<span class="string">"event_task"</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样，在执行行为树<code>5_Combine_2</code>时，如果接收到事件<code>event_task</code>，那么行为树中的事件附件将得到响应和处理，行为树的执行就会从当前的<code>5_Combine_2</code>跳转到<code>4_Combine_Task</code>。<br>&emsp;&emsp;调用FireEvent的时候，只有处于running状态的节点才响应事件，这样设计是为了允许不同的分支不同的时机同样的事件可以触发不同的行为。比如同样是BeingHit，受伤的时候，或者逃跑的时候可以对应不同的行为。如果不需要根据不同的节点相应不同的行为，只是需要响应事件，可以把事件配置在根节点上（根节点同样需要是running状态，非running状态的节点没有机会响应事件）。<br>&emsp;&emsp;另外需要补充说明的是，虽然行为树<code>4_Combine_Task</code>带有任务节点，但也可以直接将该行为树拖拽到行为树<code>5_Combine_2</code>中，如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/55.png" alt="直接使用任务行为树"></div>

<p>&emsp;&emsp;选中该任务子树后，可直接配置所需参数，如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/56.png" alt="配置参数"></div>

<h3 id="装饰器类节点"><a href="#装饰器类节点" class="headerlink" title="装饰器类节点"></a>装饰器类节点</h3><p>&emsp;&emsp;装饰器类节点作为控制分支节点，必须且只接受一个子节点。装饰器类节点首先从子节点开始执行，并根据自身的控制逻辑以及子节点的返回结果决定自身的状态。装饰节点都有&quot;子节点结束时作用&quot;属性配置，如果该值配置为真，则仅当子节点结束（成功或失败）的时候，装饰节点的装饰逻辑才起作用。</p>
<h4 id="非"><a href="#非" class="headerlink" title="非"></a>非</h4><p>&emsp;&emsp;非节点将子节点的返回值取反，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/57.png" alt="非节点"></div>

<p>&emsp;&emsp;类似于逻辑&quot;非&quot;操作，非节点对子节点的返回值执行如下操作：<br>&emsp;&emsp;1、如果子节点失败，那么此节点返回成功；<br>&emsp;&emsp;2、如果子节点成功，那么此节点返回失败；<br>&emsp;&emsp;3、如果子节点返回正在执行，则同样返回正在执行。</p>
<h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>&emsp;&emsp;时间节点用于在指定的时间内，持续调用其子节点，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/58.png" alt="时间节点"></div>

<p>&emsp;&emsp;时间节点可以配置其属性&quot;时间&quot;，该属性是float或double类型，可以配置一个常量、成员属性或方法的返回值，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/59.png" alt="时间节点属性"></div>

<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>&emsp;&emsp;循环节点循环执行子节点指定的次数，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/60.png" alt="循环节点"></div>

<p>&emsp;&emsp;循环节点配置如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/61.png" alt="循环节点属性"></div>

<p>&emsp;&emsp;<strong>次数</strong>：如果次数配置为-1，则视为无限循环，总是返回运行。否则循环执行子节点指定的次数然后返回成功，在指定次数之前则返回运行。此循环次数可以是常数，也可以是变量，当是变量的时候，每次enter的时候此循环次数被赋值，也就是每次enter的时候，循环的次数就被确定了。之后再更改该变量的值在本次循环内将不起作用，但是exit后再enter的时候会起作用；<br>&emsp;&emsp;<strong>一帧内结束</strong>：如果选择了&#39;一帧内结束&#39;，次数不可以配置为-1，节点阻塞，直到子节点在一帧内执行指定的次数后返回成功；然而如果子节点失败了，不会执行指定次数就直接返回失败；如果子节点一直返回运行，则本节点一直阻塞。但如果&quot;子节点结束时作用&quot;不为真，则不会阻塞；在&#39;一帧内结束&#39;的情况下，本节点只能成功或失败，不会返回运行。</p>
<h4 id="帧数"><a href="#帧数" class="headerlink" title="帧数"></a>帧数</h4><p>&emsp;&emsp;帧数节点用于在指定的帧数内，持续调用其子节点，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/62.png" alt="帧数节点"></div>

<p>&emsp;&emsp;帧数节点可以配置其属性&quot;帧数&quot;，该属性是int类型，可以配置一个常量、成员属性或方法的返回值，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/63.png" alt="帧数节点属性"></div>

<h4 id="计数限制"><a href="#计数限制" class="headerlink" title="计数限制"></a>计数限制</h4><p>&emsp;&emsp;计数限制节点不同于循环节点，它在 <strong>指定的循环次数到达前</strong> 返回子节点返回的状态，无论成功、失败还是正在执行，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/64.png" alt="计数限制节点"></div>

<p>&emsp;&emsp;计数限制节点在指定的循环次数到达后不再执行。如果指定的循环次数小于0，则表示只执行一次子节点并且返回子节点的返回值。<br>&emsp;&emsp;此外，计数限制节点上还可以添加中断条件作为重新开始条件，如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/65.png" alt="计数限制节点中断条件"></div>

<h4 id="输出消息"><a href="#输出消息" class="headerlink" title="输出消息"></a>输出消息</h4><p>&emsp;&emsp;输出消息节点作为调试的辅助工具，执行完子节点后，输出配置的消息，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/66.png" alt="输出消息节点"></div>

<h4 id="循环直到"><a href="#循环直到" class="headerlink" title="循环直到"></a>循环直到</h4><p>&emsp;&emsp;循环直到节点在指定的次数到达后返回成功，在指定的次数到达前一直返回正在执行。如果指定的次数小于0，则表示无限循环，总是返回正在执行。如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/67.png" alt="循环直到节点"></div>

<p>&emsp;&emsp;循环直到节点除了像循环节点可以配置循环的次数，还有一个属性&quot;直到子树&quot;需要配置，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/68.png" alt="循环直到节点属性"></div>

<p>&emsp;&emsp;循环直到节点有两个结束条件，指定的&quot;循环次数&quot;到达或者子树的返回值与配置的&quot;直到子树&quot;值一样时：<br>&emsp;&emsp;1、指定的&quot;循环次数&quot;到达的时候，则返回成功；<br>&emsp;&emsp;2、指定的&quot;循环次数&quot;小于0的时候，则是无限循环，等同于只检查子树的返回值是否满足。<br>&emsp;&emsp;子树的返回值满足的时候：<br>&emsp;&emsp;1、如果&quot;直到子树&quot;设置为真，意味着直到子树返回成功，也返回成功；<br>&emsp;&emsp;2、如果&quot;直到子树&quot;设置为假，意味着直到子树返回失败，也返回失败。</p>
<h4 id="总是成功-总是失败-总是运行"><a href="#总是成功-总是失败-总是运行" class="headerlink" title="总是成功/总是失败/总是运行"></a>总是成功/总是失败/总是运行</h4><p>&emsp;&emsp;总是成功/总是失败/总是运行将忽略子节点返回的结果，返回成功/失败/正在运行，如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/69.png" alt="总是成功节点"></div>

<p>&emsp;&emsp;在上图中，并行节点下的两个条件必定有一个返回失败，那么并行也将返回失败，由于前面有总是成功节点，所以最终仍然返回成功。</p>
<h4 id="返回成功直到-返回失败直到"><a href="#返回成功直到-返回失败直到" class="headerlink" title="返回成功直到/返回失败直到"></a>返回成功直到/返回失败直到</h4><p>&emsp;&emsp;返回成功直到节点在指定的次数到达前返回成功，指定的次数到达后返回失败。如果指定的次数小于0，则总是返回成功；返回失败直到节点在指定的次数到达前返回失败，指定的次数到达后返回成功。如果指定的次数小于0，则总是返回失败。</p>
<h3 id="状态机类节点"><a href="#状态机类节点" class="headerlink" title="状态机类节点"></a>状态机类节点</h3><p>&emsp;&emsp;behaviac组件不仅支持行为树，也支持有限状态机（FSM），并且支持行为树跟状态机的相互嵌套调用。<br>&emsp;&emsp;behaviac组件中的状态机主要用到了状态、等待状态和等待帧数状态三种节点，以及条件转换和总是转换两种附件。</p>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>&emsp;&emsp;状态节点是状态机中的基本组成部分之一，可以在状态节点上添加前置、后置以及转换等附件，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/70.png" alt="状态节点"></div>

<p>&emsp;&emsp;在状态节点上添加的前置：表明进入该状态节点时，需要执行的操作。<br>&emsp;&emsp;在状态节点上添加的后置：表明退出该状态节点时，需要执行的操作。<br>&emsp;&emsp;在状态节点上添加的转换：表明满足该转换所表示的条件时，由当前状态切换到转换所指向的下一个状态。<br>&emsp;&emsp;状态节点相关属性如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/71.png" alt="状态节点属性"></div>

<p>&emsp;&emsp;<strong>名字</strong>：为状态节点指定一个有意义的名字，以便区分其他状态节点。<br>&emsp;&emsp;<strong>方法</strong>：表示该状态节点需要执行的操作。<br>&emsp;&emsp;<strong>结束状态</strong>：如果勾选，表示该状态作为结束状态，即在执行完该状态节点之后，整个状态机也直接结束。该节点形状也将显示为圆角矩形，以示区别。</p>
<h4 id="等待状态"><a href="#等待状态" class="headerlink" title="等待状态"></a>等待状态</h4><p>&emsp;&emsp;等待状态节点是一种特殊的状态节点，可以在状态节点上添加前置、后置以及等待转换等附件。添加等待状态节点时，会自动的生成唯一的等待转换附件，不接受添加其他类型的转换附件。如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/72.png" alt="等待状态节点"></div>

<p>&emsp;&emsp;等待状态节点相关属性如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/73.png" alt="等待状态节点属性"></div>

<p>&emsp;&emsp;相比状态节点的属性，等待状态节点少了&quot;方法&quot;属性，但多出了一个&quot;持续时间&quot;属性，用来指定需要等待多长时间，可以是常数、属性或方法的返回值。</p>
<h4 id="等待帧数状态"><a href="#等待帧数状态" class="headerlink" title="等待帧数状态"></a>等待帧数状态</h4><p>&emsp;&emsp;等待帧数状态节点与等待状态节点相似，只是持续时间属性变为帧数属性，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/74.png" alt="等待帧数状态节点"></div>

<h4 id="条件转换"><a href="#条件转换" class="headerlink" title="条件转换"></a>条件转换</h4><p>&emsp;&emsp;条件转换附件是状态机中的基本组成部分之一，它表示一个条件，当这个条件满足时，由所在的状态切换到另一个状态，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/75.png" alt="条件转换附件"></div>

<p>&emsp;&emsp;其中<code>m_nVal == 2</code>为切换到等待状态的条件。条件转换的属性如下图，其中效果属性为转换附件执行完之后需要执行的额外操作：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/76.png" alt="条件转换附件属性"></div>

<h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p>&emsp;&emsp;状态转换附件是一种特殊的转换附件，根据它的配置，转换时机会有不同（ <strong>验证发现无法添加子树作为当前节点，2、3、4可能已不支持</strong> ）：<br>&emsp;&emsp;1、总跳转，表示无条件从所在的状态切换到另一个状态，如下图所示；<br>&emsp;&emsp;2、成功时，表示当所在节点是子树并且成功的时候转换；<br>&emsp;&emsp;3、失败时，表示当所在节点是子树并且失败的时候转换；<br>&emsp;&emsp;4、结束时，表示当所在节点是子树并且结束（成功或失败）的时候转换。</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/77.png" alt="状态转换附件"></div>

<h2 id="预制"><a href="#预制" class="headerlink" title="预制"></a>预制</h2><p>&emsp;&emsp;预制可以用来复用和实例化已有的行为树，如果只是直接复用行为树，预制跟引用子树的功能是一样的。但是预制还可以用来定制个别节点的配置，称之为对预制的实例化。也即，如果一棵行为树用到了一棵预制行为树，那么可以局部修改某些节点，这些修改的节点不会跟着预制行为树的更新而同步更新。</p>
<h3 id="添加预制"><a href="#添加预制" class="headerlink" title="添加预制"></a>添加预制</h3><p>&emsp;&emsp;打开示例中的任意一棵行为树，这里选中某一个节点之后右键，在弹出的菜单框中选择另存为预制行为树。这里以<code>2_Condition</code>行为树中的第一个或节点为例，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/78.png" alt="行为树"></div>

<p>&emsp;&emsp;在弹出的&quot;另存为预制&quot;窗口中，可以为当前的预制改名，然后点击&quot;确认&quot;按钮，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/79.png" alt="另存为预制"></div>

<p>&emsp;&emsp;在编辑器左侧的行为树列表中，可以看到多了<code>pf_Or</code>节点，这就是刚刚保存出来的预制行为树，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/80.png" alt="Prefabs"></div>

<p>&emsp;&emsp;在Prefabs标签下的所有预制行为树都可以直接拖拽到主视口中打开的行为树中使用，不过需要保证预制行为树跟主视口中打开的行为树的Agent类型保持兼容，也即要么类型相同，要么预制行为树的Agent类型是主视口中打开的行为树的Agent类型的基类。<br>&emsp;&emsp;双击打开预制行为树<code>pf_Or</code>，可以看到该树自动添加了根节点及其Agent类型FirstAgent，其他节点跟原有的情况保持一致，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/81.png" alt="预制行为树"></div>

<p>&emsp;&emsp;而在行为树<code>2_Condition</code>中，可以看到原来的或节点已被预制行为树<code>pf_Or</code>替代，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/82.png" alt="预制行为树已替换"></div>

<p>&emsp;&emsp;修改了预制行为树<code>pf_Or</code>中的节点，所有引用到该预制行为树的行为树都会保持相同的更新，除非在行为树中有对预制行为树的节点属性有自己的修改或定制。</p>
<h3 id="应用预制"><a href="#应用预制" class="headerlink" title="应用预制"></a>应用预制</h3><p>&emsp;&emsp;为行为树<code>2_Condition</code>拖拽一个预制行为树<code>pf_Or</code>，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/83.png" alt="使用预制行为树"></div>

<p>&emsp;&emsp;修改第二个预制<code>pf_Or</code>中ID为15的节点右值为2，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/84.png" alt="修改值"></div>

<p>&emsp;&emsp;可以看到上图ID为13和16的两个节点都变为了虚线框，表示这是预制实例化（定制）后的节点及其父节点。此时如果修改预制<code>pf_Or</code>中的或节点的第二个条件节点<code>m_nVal == 1</code>为<code>m_nVal == 3</code>，那么行为树<code>2_Condition</code>中的ID为3的条件节点右值也将更新为3，而ID为15的节点将不更新，如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/85.png" alt="定制预制行为树"></div>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>&emsp;&emsp;注意：示例压缩包中已经包含了BehaviacTest项目文件，其中的代码无需进行以下修改。</p>
<h3 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h3><p>&emsp;&emsp;编辑器中选择视图-&gt;类型信息选项，打开类型信息对话框，点击底下的应用按钮导出最新的&quot;胶水&quot;代码，通过左下角打开代码生成位置可以定位到&quot;胶水&quot;代码所在路径（工作区目录下的<code>exported\behaviac_generated\types</code>），一般在类型信息新增或有变更时才需要重新导出。</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/86.png" alt="导出代码"></div>

<p>&emsp;&emsp;之后新建一个VS项目，拷贝编辑器生成的&quot;胶水&quot;代码到项目中：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/87.png" alt="胶水代码"></div>

<p>&emsp;&emsp;添加&quot;胶水&quot;代码之后的项目如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/88.png" alt="拷贝胶水代码"></div>

<h3 id="添加逻辑代码"><a href="#添加逻辑代码" class="headerlink" title="添加逻辑代码"></a>添加逻辑代码</h3><p>&emsp;&emsp;打开上图中的FirstAgent.cpp文件，为FirstAgent的Print/PrintInt/SetInt方法添加逻辑代码，注意逻辑代码只能添加在注释&quot;///&lt;&lt;&lt; BEGIN WRITING YOUR CODE&quot;和&quot;///&lt;&lt;&lt; END WRITING YOUR CODE&quot;之间。如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FirstAgent::Print(behaviac::<span class="built_in">string</span>&amp; strText)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">///&lt;&lt;&lt; BEGIN WRITING YOUR CODE Print</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strText.c_str());</span><br><span class="line"><span class="comment">///&lt;&lt;&lt; END WRITING YOUR CODE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FirstAgent::PrintInt()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">///&lt;&lt;&lt; BEGIN WRITING YOUR CODE PrintInt</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"m_nVal=%d\n"</span>, m_nVal);</span><br><span class="line"><span class="comment">///&lt;&lt;&lt; END WRITING YOUR CODE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FirstAgent::SetInt(<span class="keyword">int</span> nVal)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">///&lt;&lt;&lt; BEGIN WRITING YOUR CODE SetInt</span></span><br><span class="line">	m_nVal = nVal;</span><br><span class="line"><span class="comment">///&lt;&lt;&lt; END WRITING YOUR CODE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改项目属性"><a href="#修改项目属性" class="headerlink" title="修改项目属性"></a>修改项目属性</h3><p>&emsp;&emsp;右键项目选择项目属性，在C/C++下的General（常规）选项中添加behaviac库的inc目录（位于behaviac源码压缩包的最顶级）为附加引入目录；在Linker下的General（常规）选项中添加behaviac库生成的lib文件所在目录为附加库目录，添加该lib文件为附加依赖项。如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/90.png" alt="附加引入目录"></div>

<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/91.png" alt="附加库目录"></div>

<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/92.png" alt="依赖项"></div>

<h3 id="添加Behaviac逻辑"><a href="#添加Behaviac逻辑" class="headerlink" title="添加Behaviac逻辑"></a>添加Behaviac逻辑</h3><p>&emsp;&emsp;1、首先，在InitBehaviac()方法中初始化behaviac的加载目录和文件格式等，如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitBehaviac</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __FUNCTION__);</span><br><span class="line">	behaviac::Workspace::GetInstance()-&gt;SetFilePath(<span class="string">"../res"</span>);	<span class="comment">// 用于设置加载编辑器导出的行为树所在的目录</span></span><br><span class="line">	behaviac::Workspace::GetInstance()-&gt;SetFileFormat(behaviac::Workspace::EFF_xml);		<span class="comment">// 用于设置加载的行为树格式，这里用的是xml格式</span></span><br><span class="line">	behaviac::Config::SetLogging(<span class="literal">true</span>);</span><br><span class="line">	behaviac::Config::SetSocketBlocking(<span class="literal">true</span>);	<span class="comment">// 等待编辑器连接上才往后继续执行</span></span><br><span class="line">	<span class="comment">//behaviac::Config::SetSocketPort(60636);	// 如果需要修改端口号，需要添加此代码</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;2、接着，创建Agent子类FirstAgent的实例，并加载指定的行为树，如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* szPath = g_arrBTPath[g_nBTIndex].c_str();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __FUNCTION__);</span><br><span class="line">	g_pFirstAgent = behaviac::Agent::Create&lt;FirstAgent&gt;();	<span class="comment">//Create()用于创建Agent子类的实例</span></span><br><span class="line">	<span class="keyword">if</span> (g_pFirstAgent == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> bRet = g_pFirstAgent-&gt;btload(szPath);	<span class="comment">//用于加载行为树，入口参数是行为树的名字，不需要加后缀</span></span><br><span class="line">	<span class="keyword">if</span> (bRet)</span><br><span class="line">	&#123;</span><br><span class="line">		g_pFirstAgent-&gt;btsetcurrent(szPath);		<span class="comment">//用于指定当前准备执行的行为树</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3、其次，开始执行行为树，如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __FUNCTION__);</span><br><span class="line">	<span class="keyword">int</span> frames = <span class="number">0</span>;</span><br><span class="line">	behaviac::EBTStatus enStatus = behaviac::BT_RUNNING;</span><br><span class="line">	<span class="keyword">while</span> (enStatus == behaviac::BT_RUNNING)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"frame %d:\n"</span>, frames);</span><br><span class="line">		behaviac::Workspace::GetInstance()-&gt;DebugUpdate();</span><br><span class="line">		enStatus = g_pFirstAgent-&gt;btexec();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;4、之后，对创建的Agent实例进行销毁释放，并清理整个工作区，如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CleanPlayer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __FUNCTION__);</span><br><span class="line">	behaviac::Agent::Destroy(g_pFirstAgent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CleanBehaviac</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, __FUNCTION__);</span><br><span class="line">	behaviac::Workspace::GetInstance()-&gt;Cleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;5、最后，在main函数中依次调用1-4中所写的函数，编译并运行程序即可。</p>
<h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><h4 id="编译behaviac运行时库"><a href="#编译behaviac运行时库" class="headerlink" title="编译behaviac运行时库"></a>编译behaviac运行时库</h4><p>&emsp;&emsp;behaviac源代码压缩包中包含了VS2013的项目文件，解压缩后打开projects/vs2013目录下的sln文件，如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/93.png" alt="behaviac项目文件"></div>

<p>&emsp;&emsp;打开之后按需选择<code>DebugStatic</code>/<code>DebugDLL</code>/<code>ReleaseDLL</code>/<code>ReleaseStatic</code>编译即可，生成的lib或dll文件在源代码根目录下的bin目录：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/94.png" alt="生成文件目录"></div>

<h4 id="逻辑代码更新问题"><a href="#逻辑代码更新问题" class="headerlink" title="逻辑代码更新问题"></a>逻辑代码更新问题</h4><p>&emsp;&emsp;当类型信息中建立好的类已添加了逻辑代码时，为避免下一次修改类型信息导致类的逻辑代码被覆盖，添加好逻辑代码之后将修改的类cpp和h文件覆盖到工作区目录下的<code>exported\behaviac_generated\types\internal</code>目录，这样在编辑器下一次生成&quot;胶水&quot;代码不会覆盖掉已有的逻辑代码。</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="连调"><a href="#连调" class="headerlink" title="连调"></a>连调</h3><p>&emsp;&emsp;连调功能是指在游戏运行的时候，编辑器可以连上游戏，实时的查看树的运行情况，变量的当前值，可以设断点等。而离线调试实际上是回放运行时产生的log。<br>&emsp;&emsp;连调需要游戏是开发版本（即宏<code>BEHAVIAC_RELEASE</code>没有被定义），发布版本下没有连调的功能。<br>&emsp;&emsp;连调流程说明如下（以文档中提供的示例BehaviacTest.zip包为例，假设已安装好Behaviac编辑器）：<br>&emsp;&emsp;1、解压缩BehaviacTest.zip，打开Project下的BehaviacTest.sln，直接编译运行。运行时，可以看到如下图所示：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/95.png" alt="运行结果"></div>

<p>&emsp;&emsp;2、使用编辑器打开HelloTest下的<code>HelloTest.workspace.xml</code>，左上角双击<code>5_Combine_2</code>和<code>4_Combine_Task</code>打开这两个行为树，并在任意节点上打断点，选中某个节点之后右键选择断点-&gt;添加进入/退出断点或按F9添加断点即可；<br>&emsp;&emsp;3、点击左上角当前工作区下的连接游戏图标，如下图：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/96.png" alt="连接游戏图标"></div>

<p>&emsp;&emsp;之后弹出连接游戏对话框，按情况勾选使用本机IP及填写IP和端口：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/97.png" alt="连接游戏面板"></div>

<p>&emsp;&emsp;连接成功后，如果已命中断点，则会以黄色框显示当前断住的节点，如下图，此时按F5可以继续执行：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/98.png" alt="调试界面"></div>

<h3 id="离线调试"><a href="#离线调试" class="headerlink" title="离线调试"></a>离线调试</h3><p>&emsp;&emsp;离线调试功能是指在编辑器里加载运行时产生的<code>_behaviac_$_.log</code>文件，如下图，可以加载<code>_behaviac_$_.log</code>文件：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/99.png" alt="分析文件"></div>

<p>&emsp;&emsp;<code>_behaviac_$_.log</code>是运行游戏时产生的log文件。一般都是产生在exe所在的目录，对于Unity，是产生在Assets的同级目录。以C++项目为例为例，调试时，log文件在项目vcxproj同级目录下：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/100.png" alt="log文件路径"></div>

<p>&emsp;&emsp;单独运行exe时，则在exe同级目录下：</p>
<div align="center"><img src="../images/2018/Simple-introduction-of-behaviac/101.png" alt="log文件路径"></div>

<p>&emsp;&emsp;在离线调试里，可以模拟游戏的运行，甚至可以设断点，然后查看变量的当前值，可以查看树的执行情况。需要注意，文件<code>_behaviac_$_.log</code>只在开发版本下产生，或是<code>Config::IsLogging</code>为true时产生。</p>
]]></content>
      
        <categories>
            
            <category> behaviac </category>
            
        </categories>
        
        
        <tags>
            
            <tag> behaviac </tag>
            
            <tag> FSM </tag>
            
            <tag> Game-AI </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用VS2015编译Cocos2dx-3.2项目]]></title>
      <url>/blog/2018/Build-cocos2dx-3_2-project-with-VS2015.html</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr>
<p>&emsp;&emsp;cocos2dx3.2应该算是大家比较熟知的一个版本了，相比后续的版本，这个版本生成的apk比较小，重点是支持WP8（软粉一枚(ง •_•)ง），然而这个版本生成的项目在VS2015上编译不过。接下来介绍如何修改使VS2015能够顺利编译项目。<a id="more"></a></p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><hr>
<p>&emsp;&emsp;用cocos2dx3.2创建一个项目（以下用<code>YourProject</code>表示项目路径），创建成功后用VS2015打开<code>proj.win32</code>下的sln文件，打开时会弹出一个升级VC编译器和库的提示，点确认即可。之后编译整个解决方案，不出意外的话会看到这些报错：<br><img src="../images/2018/Build-cocos2dx-3_2-project-with-VS2015/builderror.png" alt=""></p>
<h1 id="解决错误"><a href="#解决错误" class="headerlink" title="解决错误"></a>解决错误</h1><hr>
<p>&emsp;&emsp;接下来解决这些编译报错，双击报错信息可以定位到所在文件以及行。</p>
<h2 id="无效文本后缀XSTR"><a href="#无效文本后缀XSTR" class="headerlink" title="无效文本后缀XSTR"></a>无效文本后缀<code>XSTR</code></h2><p>&emsp;&emsp;报错文件为<code>YourProject\cocos2d\external\chipmunk\src\chipmunk.c(48)</code>。查找报错信息发现，VS2015新增了用户定义文本支持，详细见<a href="https://msdn.microsoft.com/zh-cn/library/dn919277.aspx" target="_blank" rel="noopener"><strong>MSDN:用户定义的文本</strong></a>，这里<code>XSTR(CP_VERSION_MAJOR)&quot;.&quot;XSTR(CP_VERSION_MINOR)&quot;.&quot;XSTR(CP_VERSION_RELEASE)</code>后面两个XSTR由于没有空格隔开，所以被认为是用户定义的文本，但实际上没有XSTR这个定义，所以报错。解决办法就是在分别在后面两个<code>XSTR</code>前面加上空格，即：<code>XSTR(CP_VERSION_MAJOR)&quot;.&quot; XSTR(CP_VERSION_MINOR)&quot;.&quot; XSTR(CP_VERSION_RELEASE)</code>。</p>
<h2 id="snprintf宏定义冲突"><a href="#snprintf宏定义冲突" class="headerlink" title="snprintf宏定义冲突"></a><code>snprintf</code>宏定义冲突</h2><p>&emsp;&emsp;Macro definition of snprintf conflicts with Standard Library function declaration这条报错信息的意思是<code>snprintf</code>宏定义和标准库定义冲突，说明cocos2dx在内部定义了<code>snprintf</code>宏。查看输出可以发现在这条报错信息前面还有一条警告信息，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&gt;C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\stdio.h(1925): warning C4005: \<span class="string">'snprintf\'</span>: macro redefinition (compiling <span class="built_in">source</span> file ..\base\atitc.cpp)</span><br><span class="line">1&gt;  YourProject\cocos2d\cocos\platform\win32\CCStdC.h(53): note: see previous definition of \<span class="string">'snprintf\'</span> (compiling <span class="built_in">source</span> file ..\base\atitc.cpp)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;定位到CCStdC.h文件53行，可以看到snprintf宏的定义，解决办法就是把<code>#define snprintf _snprintf</code>注释掉。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for math.h on win32 platform</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MINGW32__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(_USE_MATH_DEFINES)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> _USE_MATH_DEFINES       <span class="comment">// make M_PI can be use</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(isnan)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> isnan   _isnan</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> snprintf</span></span><br><span class="line"><span class="comment">//#define snprintf _snprintf    // 注释掉这一行即可</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __MINGW32__</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="无法解析的外部符号"><a href="#无法解析的外部符号" class="headerlink" title="无法解析的外部符号"></a>无法解析的外部符号</h2><p>&emsp;&emsp;编译错误解决了之后，重新编译发现有链接错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3&gt;libpng.lib(pngerror.obj) : error LNK2019: unresolved external symbol __imp____iob_func referenced <span class="keyword">in</span> <span class="keyword">function</span> _png_default_error</span><br><span class="line">3&gt;libtiff.lib(tif_unix.obj) : error LNK2001: unresolved external symbol __imp____iob_func</span><br><span class="line">3&gt;libjpeg.lib(jerror.obj) : error LNK2019: unresolved external symbol ___iob_func referenced <span class="keyword">in</span> <span class="keyword">function</span> _output_message</span><br><span class="line">3&gt;MSVCRTD.lib(vsnprintf.obj) : error LNK2001: unresolved external symbol __imp___vsnprintf</span><br></pre></td></tr></table></figure></p>
<h3 id="iob-func"><a href="#iob-func" class="headerlink" title="__iob_func"></a><code>__iob_func</code></h3><p>&emsp;&emsp;出现<code>__iob_func</code>链接错误的原因是早期VS版本是用<code>__iob_func</code>来定义<code>stdin</code>、<code>stdout</code>和<code>stderr</code>宏的，而VS2015是用<code>__acrt_iob_func</code>定义（以SDK 10240版本为例，三个宏定义在<code>c:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt\corecrt_wstdio.h</code>）。有以下两种解决办法：</p>
<ol>
<li>自行编译libpng、libtiff和libjpeg生成VS2015版本的lib文件；</li>
<li>从cocos2dx最新版本中拷贝libpng、libtiff和libjpeg的win32版本lib文件及头文件到cocos2dx3.2对应目录<code>YourProject\cocos2d\external</code>（<strong>不希望下载cocos2dx最新版本？查看结束部分下载我提供的附件</strong>）；<br>拷贝完成之后修改<code>YourProject\cocos2d\cocos\platform\win32\CCPlatformDefine.h</code>，在<code>#endif // CC_TARGET_PLATFORM == CC_PLATFORM_WIN32</code>之前加上如下代码：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _MSC_VER &gt;= 1900</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"libpng-2015.lib"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"libjpeg-2015.lib"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"libtiff-2015.lib"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"libpng.lib"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"libjpeg.lib"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">"libtiff.lib"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="vsnprintf"><a href="#vsnprintf" class="headerlink" title="__vsnprintf"></a><code>__vsnprintf</code></h3><p></p><p>&emsp;&emsp;出现这个问题的原因参考<a href="https://social.msdn.microsoft.com/Forums/en-US/5150eeec-4427-440f-ab19-aecb26113d31/updated-to-vs-2015-and-now-get-unresolved-external-errors?forum=vcgeneral" target="_blank" rel="noopener"><strong>MSDN Social：Updated to VS 2015 and now get Unresolved External Errors</strong></a>，解决办法是在启动项目属性中的链接器-&gt;输入-&gt;附加依赖项中加上<code>legacy_stdio_definitions.lib</code>。</p><br><img src="../images/2018/Build-cocos2dx-3_2-project-with-VS2015/add_stdio_definitions_lib.png" alt=""><p></p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><hr>
<p>&emsp;&emsp;到这里所有问题都已经解决，可以用VS2015愉快的写代码了😘<br>&emsp;&emsp;最后附上cocos2dx3.14.1版本的libpng、libtiff和libjpeg库相关文件，包含三个库的win32版本include和prebuilt目录，下载地址<a href="../attachments/cocos2d.zip"><strong>点这里</strong></a>，下载之后直接替换你的项目下的cocos2d目录即可。</p>
]]></content>
      
        <categories>
            
            <category> Cocos2dx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cocos2dx </tag>
            
            <tag> VS2015 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Trigger第三篇：创建、读取和写入json文件]]></title>
      <url>/blog/2015/TS3-create-read-write-data-with-json.html</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr>
<p>&#160; &#160; &#160; &#160;上一篇其实已经说完了这个游戏里的重要部分了，所以接下来开始写代码了。先从解析json文件开始，配置环境啥的就不写了，网上一搜大把的教程（感觉这部分其实都不用写，也有类似读取json文件的教程= =）<a id="more"></a></p>
<h1 id="地图数据json"><a href="#地图数据json" class="headerlink" title="地图数据json"></a>地图数据json</h1><hr>
<p>&#160; &#160; &#160; &#160;这里使用rapidjson读取json文件。以3.2版本为例，rapidjson头文件在项目目录\cocos2d\external\json下，如下图所示：<br><img src="../images/2015/Trigger/rapidjson.png" alt="rapidjson"><br>&#160; &#160; &#160; &#160;在使用rapidjson前，需要引入以下头文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"json/rapidjson.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"json/writer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"json/document.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"json/prettywriter.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"json/stringbuffer.h"</span></span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;接下来上地图配置加载的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载json并解析</span></span><br><span class="line"><span class="keyword">bool</span> CDataManager::LoadMapData()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> strContent = FileUtils::getInstance()-&gt;getStringFromFile(MAP_FILE_PATH);</span><br><span class="line"></span><br><span class="line">	rapidjson::Document oDoc;</span><br><span class="line">	oDoc.Parse&lt;<span class="number">0</span>&gt;(strContent.c_str());</span><br><span class="line">	<span class="keyword">if</span> (oDoc.HasParseError())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">log</span>(<span class="string">"Parse Error: %s\n"</span>, oDoc.GetParseError());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (oDoc.IsNull() || !oDoc.IsArray())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oDoc.Size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		MapInfo mapInfo;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//color</span></span><br><span class="line">		<span class="keyword">if</span> (oDoc[i][<span class="string">"color"</span>].IsNull())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		mapInfo.iColor = oDoc[i][<span class="string">"color"</span>].GetInt();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//id</span></span><br><span class="line">		<span class="keyword">if</span> (oDoc[i][<span class="string">"id"</span>].IsNull())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		mapInfo.iID = oDoc[i][<span class="string">"id"</span>].GetInt();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//beat</span></span><br><span class="line">		<span class="keyword">if</span> (oDoc[i][<span class="string">"beat"</span>].IsNull())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		mapInfo.iBeat = oDoc[i][<span class="string">"beat"</span>].GetInt();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//map</span></span><br><span class="line">		<span class="keyword">if</span> (oDoc[i][<span class="string">"map"</span>].IsNull() || (!oDoc[i][<span class="string">"map"</span>].IsArray()))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//每行数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oDoc[i][<span class="string">"map"</span>].Size(); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (oDoc[i][<span class="string">"map"</span>][j].IsNull() </span><br><span class="line">				|| (!oDoc[i][<span class="string">"map"</span>][j].IsArray()))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; oDoc[i][<span class="string">"map"</span>][j].Size(); k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (oDoc[i][<span class="string">"map"</span>][j][k].IsNull())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">int</span> iValue = oDoc[i][<span class="string">"map"</span>][j][k].GetInt();</span><br><span class="line">				<span class="comment">//每行数据存入vecMap中</span></span><br><span class="line">				mapInfo.vecMap.push_back(iValue);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//mapitem</span></span><br><span class="line">		<span class="keyword">if</span> (oDoc[i][<span class="string">"mapitem"</span>].IsNull() </span><br><span class="line">			|| (!oDoc[i][<span class="string">"mapitem"</span>].IsArray()))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oDoc[i][<span class="string">"mapitem"</span>].Size(); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (oDoc[i][<span class="string">"mapitem"</span>][j].IsNull())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">string</span> strMapItem = oDoc[i][<span class="string">"mapitem"</span>][j].GetString();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> iArrow[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">			SplitString(strMapItem, <span class="string">'_'</span>, iArrow);</span><br><span class="line"></span><br><span class="line">			ArrowInfo arrowInfo;</span><br><span class="line">			<span class="comment">//X和Y位置互换</span></span><br><span class="line">			arrowInfo.iY = iArrow[<span class="number">0</span>];</span><br><span class="line">			arrowInfo.iX = iArrow[<span class="number">1</span>];</span><br><span class="line">			arrowInfo.iType = iArrow[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">			<span class="comment">//存入vecMapItem中</span></span><br><span class="line">			mapInfo.vecMapItem.push_back(arrowInfo);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//useritem</span></span><br><span class="line">		<span class="keyword">if</span> (oDoc[i][<span class="string">"useritem"</span>].IsNull() </span><br><span class="line">			|| (!oDoc[i][<span class="string">"useritem"</span>].IsArray()))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oDoc[i][<span class="string">"useritem"</span>].Size(); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (oDoc[i][<span class="string">"useritem"</span>][j].IsNull())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> iNum = oDoc[i][<span class="string">"useritem"</span>][j].GetInt();</span><br><span class="line"></span><br><span class="line">			mapInfo.vecUserItem.push_back(iNum);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		m_oMapVec.push_back(mapInfo);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;以上代码涉及到了两个结构体，MapInfo和ArrowInfo，对应定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//箭头信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArrowInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> iX;		<span class="comment">//横向位置索引</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> iY;		<span class="comment">//纵向位置索引</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> iType;	<span class="comment">//箭头类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MapInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> iColor;	<span class="comment">//颜色序号，也是主题序号</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> iID;	<span class="comment">//关卡ID</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> iBeat;	<span class="comment">//可点击次数</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecMap;	<span class="comment">//六边形行列分布序列</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;ArrowInfo&gt; vecMapItem;	<span class="comment">//地图中箭头分布</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecUserItem;	<span class="comment">//可用箭头数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;另外还有一个函数SplitString，其负责解析出字符串中的三个数值，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除string中所有位置出现过的某个字符</span></span><br><span class="line"><span class="keyword">void</span> CDataManager::SplitString(<span class="built_in">string</span> &amp;srcStr, <span class="keyword">char</span> chTarget, <span class="keyword">int</span>* pArray)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> iPos = srcStr.find_first_of(<span class="string">'_'</span>);</span><br><span class="line">	<span class="built_in">string</span> strTemp = srcStr.substr(<span class="number">0</span>, iPos);</span><br><span class="line">	pArray[<span class="number">0</span>] = atoi(strTemp.c_str());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> iNewPos = srcStr.find_first_of(<span class="string">'_'</span>, iPos + <span class="number">1</span>);</span><br><span class="line">	strTemp = srcStr.substr(iPos + <span class="number">1</span>, iNewPos - iPos - <span class="number">1</span>);</span><br><span class="line">	pArray[<span class="number">1</span>] = atoi(strTemp.c_str());</span><br><span class="line"></span><br><span class="line">	iPos = srcStr.find_first_of(<span class="string">'_'</span>, iNewPos + <span class="number">1</span>);</span><br><span class="line">	strTemp = srcStr.substr(iNewPos + <span class="number">1</span>, iPos - iNewPos - <span class="number">1</span>);</span><br><span class="line">	pArray[<span class="number">2</span>] = atoi(strTemp.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="进度数据json"><a href="#进度数据json" class="headerlink" title="进度数据json"></a>进度数据json</h1><hr>
<p>&#160; &#160; &#160; &#160;现在需要考虑一个问题，游戏的进度该如何保存？使用UserDefault类？很显然是不行的，因为需要记录每个关卡的分数情况，200个关卡用UserDefault去存储的话显然够呛，所以这里可以考虑使用json文件保存游戏进度数据（当然，用xml也是可以的）。进度数据文件格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"score"</span>:600,<span class="string">"level"</span>:200,<span class="string">"data"</span>:[3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3]&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;先写个创建进度数据文件的函数。因为第一次打开游戏时，进度是木有的，所以需要先建好进度数据文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CDataManager::InitUserData(<span class="keyword">const</span> <span class="keyword">char</span>* pName)</span><br><span class="line">&#123;</span><br><span class="line">	rapidjson::Document oWriteDoc;</span><br><span class="line">	oWriteDoc.SetObject();</span><br><span class="line">	rapidjson::Document::AllocatorType&amp; allocator = oWriteDoc.GetAllocator();</span><br><span class="line">	rapidjson::<span class="function">Value <span class="title">oArray</span><span class="params">(rapidjson::kArrayType)</span></span>;</span><br><span class="line"></span><br><span class="line">	oWriteDoc.AddMember(<span class="string">"score"</span>, <span class="number">0</span>, allocator);</span><br><span class="line">	oWriteDoc.AddMember(<span class="string">"level"</span>, <span class="number">0</span>, allocator);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化数据</span></span><br><span class="line">	m_stUserInfo.iLevel = <span class="number">0</span>;</span><br><span class="line">	m_stUserInfo.iScore = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TOTAL_LEVEL_NUM; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		m_stUserInfo.vecData.push_back(<span class="number">0</span>);</span><br><span class="line">		oArray.PushBack(<span class="number">0</span>, allocator);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	oWriteDoc.AddMember(<span class="string">"data"</span>, oArray, allocator);</span><br><span class="line"></span><br><span class="line">	rapidjson::StringBuffer oBuffer;</span><br><span class="line">	rapidjson::Writer&lt;rapidjson::StringBuffer&gt; oWriter(oBuffer);</span><br><span class="line">	oWriteDoc.Accept(oWriter);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//写入</span></span><br><span class="line">	FILE* pFile = fopen(pName, <span class="string">"wb+"</span>);</span><br><span class="line">	<span class="keyword">if</span> (pFile == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">log</span>(<span class="string">"Open File '%s' Failed."</span>, pName);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fputs</span>(oBuffer.GetString(), pFile);</span><br><span class="line">	fclose(pFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里传入参数pName即要写入的进度数据文件路径，由于创建时没有进度，所以score和level都是0，各个关卡分数记录也是0。<br>&#160; &#160; &#160; &#160;接下来写加载进度数据文件的函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载用户数据</span></span><br><span class="line"><span class="keyword">bool</span> CDataManager::LoadUserData()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> strPath = FileUtils::getInstance()-&gt;getWritablePath() + <span class="built_in">string</span>(SAVE_DATA_PATH);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG_</span></span><br><span class="line">	<span class="built_in">log</span>(<span class="string">"UserData Path:%s\n"</span>, strPath.c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> strContent = FileUtils::getInstance()-&gt;getStringFromFile(strPath);</span><br><span class="line">	rapidjson::Document oDoc;</span><br><span class="line">	oDoc.Parse&lt;<span class="number">0</span>&gt;(strContent.c_str());</span><br><span class="line">	<span class="keyword">if</span> (oDoc.HasParseError() || oDoc.IsNull())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//log("CDataManager::LoadUserData Load 'oDoc' Error.");</span></span><br><span class="line">		InitUserData(strPath.c_str());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当前获得的分数</span></span><br><span class="line">	<span class="keyword">if</span> (oDoc[<span class="string">"score"</span>].IsNull())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">log</span>(<span class="string">"CDataManager::LoadUserData Load 'score' Error."</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m_stUserInfo.iScore = oDoc[<span class="string">"score"</span>].GetInt();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//已通过关卡数量，因为不可能跨关卡，所以也表示当前通过的最后一关</span></span><br><span class="line">	<span class="keyword">if</span> (oDoc[<span class="string">"level"</span>].IsNull())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">log</span>(<span class="string">"CDataManager::LoadUserData Load 'level' Error."</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m_stUserInfo.iLevel = oDoc[<span class="string">"level"</span>].GetInt();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//所有关卡当前信息</span></span><br><span class="line">	<span class="keyword">if</span> (oDoc[<span class="string">"data"</span>].IsNull() || (!oDoc[<span class="string">"data"</span>].IsArray()))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">log</span>(<span class="string">"CDataManager::LoadUserData Load 'data' Error."</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oDoc[<span class="string">"data"</span>].Size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (oDoc[<span class="string">"data"</span>][i].IsNull())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">log</span>(<span class="string">"CDataManager::LoadUserData Load 'oDoc[data][%d]' Error."</span>, i);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> iValue = oDoc[<span class="string">"data"</span>][i].GetInt();</span><br><span class="line">		m_stUserInfo.vecData.push_back(iValue);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;需要注意的是，默认当进度数据json文件读取失败时，说明json文件不存在，需要重新建立，即调用InitUserData函数创建进度数据文件。m_stUserInfo中保存了读取的进度数据，其类型是UserInfo结构体类型，UserInfo定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> iScore;		<span class="comment">//分数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> iLevel;		<span class="comment">//当前通过关卡数</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vecData;	<span class="comment">//关卡得分数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;有了读取函数当然少不了写入函数，进度数据保存函数如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户数据写入到指定文件中</span></span><br><span class="line"><span class="keyword">bool</span> CDataManager::SaveUserData()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> strPath = FileUtils::getInstance()-&gt;getWritablePath() + <span class="built_in">string</span>(SAVE_DATA_PATH);</span><br><span class="line">	<span class="built_in">string</span> strContent = FileUtils::getInstance()-&gt;getStringFromFile(strPath);</span><br><span class="line">	rapidjson::Document oDoc;</span><br><span class="line">	oDoc.Parse&lt;<span class="number">0</span>&gt;(strContent.c_str());</span><br><span class="line">	<span class="keyword">if</span> (oDoc.HasParseError())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">log</span>(<span class="string">"Parse Error: %s\n"</span>, oDoc.GetParseError());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (oDoc.IsNull())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新分数</span></span><br><span class="line">	<span class="keyword">if</span> (oDoc[<span class="string">"score"</span>].IsNull())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	oDoc[<span class="string">"score"</span>].SetInt(m_stUserInfo.iScore);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新通过的关卡数量</span></span><br><span class="line">	<span class="keyword">if</span> (oDoc[<span class="string">"level"</span>].IsNull())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	oDoc[<span class="string">"level"</span>].SetInt(m_stUserInfo.iLevel);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新关卡当前信息</span></span><br><span class="line">	<span class="keyword">if</span> (oDoc[<span class="string">"data"</span>].IsNull() || !oDoc[<span class="string">"data"</span>].IsArray())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> iVecSize = m_stUserInfo.vecData.size();</span><br><span class="line">	<span class="keyword">int</span> iJsonSize = oDoc[<span class="string">"data"</span>].Size();</span><br><span class="line">	<span class="keyword">if</span> (iVecSize != iJsonSize)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">log</span>(<span class="string">"Error: %d(iVecSize) != %d(iJsonSize)\n"</span>, iVecSize, iJsonSize);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (rapidjson::SizeType i = <span class="number">0</span>; i &lt; oDoc[<span class="string">"data"</span>].Capacity(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (oDoc[<span class="string">"data"</span>][i].IsNull())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		oDoc[<span class="string">"data"</span>][i].SetInt(m_stUserInfo.vecData[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//准备写入数据</span></span><br><span class="line">	rapidjson::StringBuffer oBuffer;</span><br><span class="line">	rapidjson::Writer&lt;rapidjson::StringBuffer&gt; oWriter(oBuffer);</span><br><span class="line">	oDoc.Accept(oWriter);</span><br><span class="line"></span><br><span class="line">	FILE* pFile = fopen(strPath.c_str(), <span class="string">"wb+"</span>);</span><br><span class="line">	<span class="keyword">if</span> (pFile == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">log</span>(<span class="string">"Error: Open File '%s' Failed.\n"</span>, strPath.c_str());</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fputs</span>(oBuffer.GetString(), pFile);</span><br><span class="line">	fclose(pFile);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG_</span></span><br><span class="line">	<span class="built_in">log</span>(<span class="string">"UserDataPath:%s"</span>, strPath.c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;好了，json文件创建、读取和写入部分先说到这，如果有什么不明白的地方可以联系我。</p>
]]></content>
      
        <categories>
            
            <category> Trigger </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Trigger </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Trigger第二篇：关卡布局]]></title>
      <url>/blog/2015/TS2-map-layout.html</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr>
<p>&#160; &#160; &#160; &#160;原本打算写如何把json转换为plist文件，但是后来发现有些问题，所以暂时先不写了，等以后有时间补上。这一篇写写最主要的部分：关卡的布局。<a id="more"></a></p>
<h1 id="关卡地图"><a href="#关卡地图" class="headerlink" title="关卡地图"></a>关卡地图</h1><hr>
<p>&#160; &#160; &#160; &#160;第一篇里简单的说明了下地图文件levelmap.json里的数据，每一关都有一个多个六边形的组成的地图（暂且称之为地图吧），奇数行包含7个数字，偶数行包含6个数字，之所以这么安排是为了使整个地图可以居中对齐。<br>&#160; &#160; &#160; &#160;以第一个主题（即大关卡，暂且称之为主题）第1个关卡地图为例，其地图数据如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"color"</span>:0,  <span class="string">"id"</span>:1</span><br><span class="line">...</span><br><span class="line">[0,1,1,1,0,0,0],</span><br><span class="line">[1,2,2,1,0,0],</span><br><span class="line">[1,2,2,2,1,0,0],</span><br><span class="line">[1,2,2,1,0,0],</span><br><span class="line">[0,1,1,1,0,0,0],</span><br><span class="line">[0,0,0,0,0,0],</span><br><span class="line">[0,0,0,0,0,0,0],</span><br><span class="line">[0,0,0,0,0,0],</span><br><span class="line">[0,0,0,0,0,0,0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;其中0表示该位置无六边形，1表示白色六边形，2表示主题色六边形，主题色序号即关卡属性中的color字段。先试着把整个地图画出来（忽略每行两个六边形之间的间距）：<br><img src="../images/2015/Trigger/map1.png" alt="初步的地图"><br>&#160; &#160; &#160; &#160;发现问题了没，嗯，没有六边形的位置实际上也是需要空出来的，再试着重新画一次：<br><img src="../images/2015/Trigger/map2.png" alt="保留了空白位置"><br>&#160; &#160; &#160; &#160;这回好像和目标地图有那么点像了，但是还是不太对，试着把每行居中调整一下：<br><img src="../images/2015/Trigger/map3.png" alt="每行居中"><br>&#160; &#160; &#160; &#160;这回和目标地图有八分相似了，然而还是有些问题，两行之间的间距太大，需要再稍微调整一下。嗯，这些是细节问题，可以后续在写代码时去控制。说到这，地图细节这一块就差不多了，好像很简单吧，然而我在写的时候调试了好久，才总算弄出来了= =</p>
<h1 id="数字和箭头"><a href="#数字和箭头" class="headerlink" title="数字和箭头"></a>数字和箭头</h1><hr>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><hr>
<p>&#160; &#160; &#160; &#160;从第四个主题第1关开始，之后的部分关卡就有了数字，分为以下两种情况：<br>&#160; &#160; &#160; &#160;1、单个位置数值&lt;10：该六边形颜色为主题色，数字为白色，数字值为该位置数值-2。例如：某个位置数值为5，那么这个位置是一个主题色的六边形，包含了一个白色的数字3。<br>&#160; &#160; &#160; &#160;2、单个位置数值&gt;20：该六边形颜色为白色，数字为主题色，数字值为该位置数值最后一位-1。例如：某个位置数值为22，那么这个位置是一个白色的六边形，包含了一个主题色的数字1。<br>&#160; &#160; &#160; &#160;以第四个主题第6关为例，该地图包含6个有数字的六边形，六边形都是白色，数字都是主题色。其地图数据如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"color"</span>:3,  <span class="string">"id"</span>:6</span><br><span class="line">...</span><br><span class="line">[0,22,1,22,0,0,0],</span><br><span class="line">[2,1,1,2,0,0],</span><br><span class="line">[22,1,2,1,22,0,0],</span><br><span class="line">[1,1,1,1,0,0],</span><br><span class="line">[0,22,2,22,0,0,0],</span><br><span class="line">[0,0,0,0,0,0],</span><br><span class="line">[0,0,0,0,0,0,0],</span><br><span class="line">[0,0,0,0,0,0],</span><br><span class="line">[0,0,0,0,0,0,0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;第四个主题第6关关卡截图：<br><img src="../images/2015/Trigger/map4-6.png" alt="第四个主题第6关地图"></p>
<h2 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h2><hr>
<p>&#160; &#160; &#160; &#160;从第三个主题第5关开始，之后的部分关卡就有了箭头，箭头对应的是mapitem数组中的配置，每个箭头数据配置如下形式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"y_x_arrow"</span></span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;是的，没有看错，这里x和y的位置索引是反过来的。后面的arrow数值表示箭头的序号，第一篇中已经说明了。以第三个主题第5关为例，关卡包含的箭头配置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"color"</span>:2,  <span class="string">"id"</span>:5</span><br><span class="line">...</span><br><span class="line"><span class="string">"mapitem"</span>:[<span class="string">"0_1_3"</span>,<span class="string">"3_1_2"</span>,<span class="string">"2_2_4"</span>,<span class="string">"2_4_1"</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;来看看第三个主题第5关的关卡截图：<br><img src="../images/2015/Trigger/map3-5.png" alt="第三个主题第5关地图"><br>&#160; &#160; &#160; &#160;第三个主题第5关的地图数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"color"</span>:2,  <span class="string">"id"</span>:5</span><br><span class="line">...</span><br><span class="line">[0,2,1,2,0,0,0],</span><br><span class="line">[2,1,1,2,0,0],</span><br><span class="line">[2,1,2,1,2,0,0],</span><br><span class="line">[1,1,1,1,0,0],</span><br><span class="line">[0,2,2,2,0,0,0],</span><br><span class="line">[0,0,0,0,0,0],</span><br><span class="line">[0,0,0,0,0,0,0],</span><br><span class="line">[0,0,0,0,0,0],</span><br><span class="line">[0,0,0,0,0,0,0]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;和第一个主题第1关地图类似，只是有些位置颜色发生了变化。先来看看左边的箭头，左边的箭头对应的是mapitem里的第一个字符串，也就是”0_1_3”：1也就是第1行（从0开始），0也就是第0列，也就是说箭头是在第2行第一个数字对应的六边形位置，它的颜色正好是主题色……后面的我想应该都可以看出来了。</p>
<h2 id="可用箭头"><a href="#可用箭头" class="headerlink" title="可用箭头"></a>可用箭头</h2><hr>
<p>&#160; &#160; &#160; &#160;从第三个主题第9关开始，之后的部分关卡就有了可用箭头，可用箭头在下方5个六边形中，配置对应关卡配置中的useritem数组。以第三个主题第10关为例，该关卡中有3个可用箭头：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"color"</span>:2,  <span class="string">"id"</span>:10</span><br><span class="line">...</span><br><span class="line"><span class="string">"useritem"</span>:[3,2,4]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;数字3、2、4表示箭头序号，分别对应<img src="../images/2015/Trigger/arrow3.png" alt="">、<img src="../images/2015/Trigger/arrow2.png" alt="">和<img src="../images/2015/Trigger/arrow4.png" alt="">三个箭头。再来看看关卡截图：<br><img src="../images/2015/Trigger/map3-10.png" alt="第三个主题第10关"></p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><hr>
<p>&#160; &#160; &#160; &#160;关卡布局这一块先说到这，下一篇说说在cocos2d-x中读取json文件的那些事。</p>
]]></content>
      
        <categories>
            
            <category> Trigger </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Trigger </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Trigger第一篇：简介以及资源分析]]></title>
      <url>/blog/2015/TS1-resources-analyze.html</url>
      <content type="html"><![CDATA[<h1 id="开篇之前"><a href="#开篇之前" class="headerlink" title="开篇之前"></a>开篇之前</h1><hr>
<p>&#160; &#160; &#160; &#160;想想学Cocos2d-x还是在大四上学期开始的，从那时到现在，一直想做一个自己的游戏，可能是因为自己创意不够吧，一直没这个机会，另外，和自己的水平也有很大关系。这次做的Trigger，依然是仿照写的（也就是资源是拿来的，仅仅是代码是我写的= =）。不过还好，感觉这次做的也还行，大部分功能都做好了，除了一些帮助没做（估计也没多少人会玩，所以帮助就不打算做了）。另外，也是第一次发布了WP版，捣鼓了两天弄出来了，期间也遇到了各种问题……扯得有点远了。<a id="more"></a></p>
<h1 id="Trigger介绍"><a href="#Trigger介绍" class="headerlink" title="Trigger介绍"></a>Trigger介绍</h1><hr>
<p>&#160; &#160; &#160; &#160;一开始玩这游戏的时候感觉还不错，越到后面越难，难的都不想玩了（虐心的游戏(╯‵□′)╯︵┻━┻），先来段原版的介绍（app链接：<a href="http://www.coolapk.com/game/com.orszdxet.java.TriggerApp/" target="_blank" rel="noopener">http://www.coolapk.com/game/com.orszdxet.java.TriggerApp/</a>）：<br>&#160; &#160; &#160; &#160;橘红色与白色的六边形相互比邻，当你点击其中一块时，它会连同相邻的图形一起变换颜色。而你的目标就是要在有限的点击次数内，使所有的图形都变为白色。<br>&#160; &#160; &#160; &#160;每个关卡都会有提示最低完成步数，当你耗尽之后还会有额外的10次动作机会。以限定的步数完成就会获得三星的评价，利用额外的机会则会相应降低评价，追求满星的玩家就要多动动脑了。<br>&#160; &#160; &#160; &#160;游戏内有十大关卡，每个大关又有二十小关，难度会不断增加，喜欢挑战的玩家绝对不能错过！<br>&#160; &#160; &#160; &#160;★游戏特色★<br>&#160; &#160; &#160; &#160;★★★★★简单有趣的玩法<br>&#160; &#160; &#160; &#160;★★★★★大方美观的图形<br>&#160; &#160; &#160; &#160;★★★★★不断升级的挑战<br>&#160; &#160; &#160; &#160;★★★★★锻炼你的判断力<br>&#160; &#160; &#160; &#160;来几张游戏的截图：<br><img src="../images/2015/Trigger/menu.png" width="360" height="240" alt="菜单界面" align="center"><br><img src="../images/2015/Trigger/select.png" width="360" height="240" alt="选关界面" align="center"><br><img src="../images/2015/Trigger/game.png" width="360" height="240" alt="游戏界面" align="center"></p>
<p>&#160; &#160; &#160; &#160;嗯，介绍就先到这了，如果要了解更多内容，下载个玩玩就是了→_→</p>
<h1 id="资源提取"><a href="#资源提取" class="headerlink" title="资源提取"></a>资源提取</h1><hr>
<p>&#160; &#160; &#160; &#160;下载个原版apk然后WinRAR打开，找到resources文件夹（\assets\egret-game\resource），先把它解压出来。<br><img src="../images/2015/Trigger/unpack.png" alt="解压出来的resource文件夹"><br>&#160; &#160; &#160; &#160;再看看apk里的其他文件夹，可以发现，这里面好多广告和其他游戏宣传内容，那些没有后缀的文件重命名为png后缀就可看出来了。（不植入广告肿么赚钱？(╯‵□′)╯︵┻━┻）<br>&#160; &#160; &#160; &#160;另外搜索了下egret-game，这个是一款HTML5的游戏引擎，Egret是白鹭的意思，据说Egret游戏引擎可一次开发分别部署在android、IOS和WP原生平台或者HTML版本。《围住神经猫》就是这个引擎做出来的，感兴趣的可以去看看。</p>
<h1 id="资源分析"><a href="#资源分析" class="headerlink" title="资源分析"></a>资源分析</h1><hr>
<h2 id="资源描述文件resource-json"><a href="#资源描述文件resource-json" class="headerlink" title="资源描述文件resource.json"></a>资源描述文件resource.json</h2><p>&#160; &#160; &#160; &#160;先来看看最外面的文件resource.json（theme.thm这个是空的所以略过）。resource.json文件主要是所有资源的描述以及分组信息，例如：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"name"</span>:<span class="string">"block_json_json"</span>,</span><br><span class="line">	<span class="attr">"subkeys"</span>:<span class="string">"block_0,block_1,block_2,block_3,block_4,block_5,block_6,block_7,block_8,block_9,block_w"</span>,</span><br><span class="line">	<span class="attr">"type"</span>:<span class="string">"sheet"</span>,</span><br><span class="line">	<span class="attr">"url"</span>:<span class="string">"assets/block_json.json"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这一段json代码意思就是block_json_json这一组里包含block_0.png到block_w.png共10个文件，这里省去了后缀。url即这一些资源对应的打包数据文件，即assets/block_json.json里包含了这十张图片的打包数据，例如：位置、宽高等。</p>
<h2 id="打包资源数据文件"><a href="#打包资源数据文件" class="headerlink" title="打包资源数据文件"></a>打包资源数据文件</h2><p>&#160; &#160; &#160; &#160;接下来看看assets里都有啥：<br><img src="../images/2015/Trigger/assets.png" alt="assets目录"><br>&#160; &#160; &#160; &#160;可以看出assets里存放了游戏中所有的资源，包括音效、图片以及打包图片对应的json文件等。先打开一个json文件看看是怎么打包图片的，以block_json.json为例，block_json.json代码如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"file"</span>:<span class="string">"block.png"</span>,<span class="attr">"frames"</span>:&#123;</span><br><span class="line"><span class="attr">"block_1"</span>:&#123;<span class="attr">"x"</span>:<span class="number">1</span>,<span class="attr">"y"</span>:<span class="number">1</span>,<span class="attr">"w"</span>:<span class="number">60</span>,<span class="attr">"h"</span>:<span class="number">63</span>,<span class="attr">"offX"</span>:<span class="number">0</span>,<span class="attr">"offY"</span>:<span class="number">0</span>,<span class="attr">"sourceW"</span>:<span class="number">60</span>,<span class="attr">"sourceH"</span>:<span class="number">63</span>&#125;,</span><br><span class="line"><span class="attr">"block_2"</span>:&#123;<span class="attr">"x"</span>:<span class="number">63</span>,<span class="attr">"y"</span>:<span class="number">1</span>,<span class="attr">"w"</span>:<span class="number">60</span>,<span class="attr">"h"</span>:<span class="number">63</span>,<span class="attr">"offX"</span>:<span class="number">0</span>,<span class="attr">"offY"</span>:<span class="number">0</span>,<span class="attr">"sourceW"</span>:<span class="number">60</span>,<span class="attr">"sourceH"</span>:<span class="number">63</span>&#125;,</span><br><span class="line"><span class="attr">"block_3"</span>:&#123;<span class="attr">"x"</span>:<span class="number">125</span>,<span class="attr">"y"</span>:<span class="number">1</span>,<span class="attr">"w"</span>:<span class="number">60</span>,<span class="attr">"h"</span>:<span class="number">63</span>,<span class="attr">"offX"</span>:<span class="number">0</span>,<span class="attr">"offY"</span>:<span class="number">0</span>,<span class="attr">"sourceW"</span>:<span class="number">60</span>,<span class="attr">"sourceH"</span>:<span class="number">63</span>&#125;,</span><br><span class="line"><span class="attr">"block_4"</span>:&#123;<span class="attr">"x"</span>:<span class="number">187</span>,<span class="attr">"y"</span>:<span class="number">1</span>,<span class="attr">"w"</span>:<span class="number">60</span>,<span class="attr">"h"</span>:<span class="number">63</span>,<span class="attr">"offX"</span>:<span class="number">0</span>,<span class="attr">"offY"</span>:<span class="number">0</span>,<span class="attr">"sourceW"</span>:<span class="number">60</span>,<span class="attr">"sourceH"</span>:<span class="number">63</span>&#125;,</span><br><span class="line"><span class="attr">"block_5"</span>:&#123;<span class="attr">"x"</span>:<span class="number">1</span>,<span class="attr">"y"</span>:<span class="number">66</span>,<span class="attr">"w"</span>:<span class="number">60</span>,<span class="attr">"h"</span>:<span class="number">63</span>,<span class="attr">"offX"</span>:<span class="number">0</span>,<span class="attr">"offY"</span>:<span class="number">0</span>,<span class="attr">"sourceW"</span>:<span class="number">60</span>,<span class="attr">"sourceH"</span>:<span class="number">63</span>&#125;,</span><br><span class="line"><span class="attr">"block_6"</span>:&#123;<span class="attr">"x"</span>:<span class="number">63</span>,<span class="attr">"y"</span>:<span class="number">66</span>,<span class="attr">"w"</span>:<span class="number">60</span>,<span class="attr">"h"</span>:<span class="number">63</span>,<span class="attr">"offX"</span>:<span class="number">0</span>,<span class="attr">"offY"</span>:<span class="number">0</span>,<span class="attr">"sourceW"</span>:<span class="number">60</span>,<span class="attr">"sourceH"</span>:<span class="number">63</span>&#125;,</span><br><span class="line"><span class="attr">"block_7"</span>:&#123;<span class="attr">"x"</span>:<span class="number">125</span>,<span class="attr">"y"</span>:<span class="number">66</span>,<span class="attr">"w"</span>:<span class="number">60</span>,<span class="attr">"h"</span>:<span class="number">63</span>,<span class="attr">"offX"</span>:<span class="number">0</span>,<span class="attr">"offY"</span>:<span class="number">0</span>,<span class="attr">"sourceW"</span>:<span class="number">60</span>,<span class="attr">"sourceH"</span>:<span class="number">63</span>&#125;,</span><br><span class="line"><span class="attr">"block_8"</span>:&#123;<span class="attr">"x"</span>:<span class="number">187</span>,<span class="attr">"y"</span>:<span class="number">66</span>,<span class="attr">"w"</span>:<span class="number">60</span>,<span class="attr">"h"</span>:<span class="number">63</span>,<span class="attr">"offX"</span>:<span class="number">0</span>,<span class="attr">"offY"</span>:<span class="number">0</span>,<span class="attr">"sourceW"</span>:<span class="number">60</span>,<span class="attr">"sourceH"</span>:<span class="number">63</span>&#125;,</span><br><span class="line"><span class="attr">"block_9"</span>:&#123;<span class="attr">"x"</span>:<span class="number">1</span>,<span class="attr">"y"</span>:<span class="number">131</span>,<span class="attr">"w"</span>:<span class="number">60</span>,<span class="attr">"h"</span>:<span class="number">63</span>,<span class="attr">"offX"</span>:<span class="number">0</span>,<span class="attr">"offY"</span>:<span class="number">0</span>,<span class="attr">"sourceW"</span>:<span class="number">60</span>,<span class="attr">"sourceH"</span>:<span class="number">63</span>&#125;,</span><br><span class="line"><span class="attr">"block_w"</span>:&#123;<span class="attr">"x"</span>:<span class="number">63</span>,<span class="attr">"y"</span>:<span class="number">131</span>,<span class="attr">"w"</span>:<span class="number">60</span>,<span class="attr">"h"</span>:<span class="number">63</span>,<span class="attr">"offX"</span>:<span class="number">0</span>,<span class="attr">"offY"</span>:<span class="number">0</span>,<span class="attr">"sourceW"</span>:<span class="number">60</span>,<span class="attr">"sourceH"</span>:<span class="number">63</span>&#125;,</span><br><span class="line"><span class="attr">"block_0"</span>:&#123;<span class="attr">"x"</span>:<span class="number">125</span>,<span class="attr">"y"</span>:<span class="number">131</span>,<span class="attr">"w"</span>:<span class="number">60</span>,<span class="attr">"h"</span>:<span class="number">63</span>,<span class="attr">"offX"</span>:<span class="number">0</span>,<span class="attr">"offY"</span>:<span class="number">0</span>,<span class="attr">"sourceW"</span>:<span class="number">60</span>,<span class="attr">"sourceH"</span>:<span class="number">63</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;是的，正如刚刚所说，block_json.json包含了从block_1开始到block_0结束十张图片的打包数据。这里x和y表示图片中心点在打包的图片block.png中的位置，w和h表示图片的有效宽高，offX和offY表示图像区域中心点与整体区域中心点的偏移量，sourceW和sourceH表示源图片的宽高。</p>
<h2 id="关卡数据文件map-json"><a href="#关卡数据文件map-json" class="headerlink" title="关卡数据文件map.json"></a>关卡数据文件map.json</h2><p>&#160; &#160; &#160; &#160;接下来转到config目录，先看看levelmap.json文件，这个文件包含了十个大关200个关卡的数据，选取一个有代表性的关卡数据如下所示：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"color":8,"id":20,"beat":6,"map":[[0,0,0,23,0,0,0],[0,0,2,2,0,0],[23,2,1,2,1,2,23],[2,2,1,1,2,2],[0,1,1,1,1,1,0],[2,2,1,1,2,2],[23,2,1,2,1,2,23],[0,0,2,2,0,0],[0,0,0,23,0,0,0]],"mapitem":["1_4_1","5_4_1"],"useritem":[2,2,2,3]&#125;,</span><br></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;上一段json代码描述的是第9大关（从0开始）第20关（从1开始）的关卡数据，其中color表示关卡对应颜色序号，也表示大关卡序号；id表示关卡序号；beat表示本关可用点击次数；之后的map数组表示关卡中每行每列对应的六边形状态。可以看出，关卡总共有9行数据，奇数行有7个数字，偶数行有6个数字，每个数值对应每一个六边形的状态：0表示该六边形不存在，1表示白色，2表示六边形颜色与关卡颜色相同，大于2且小于10的数表示该六边形颜色与主题色相同且包含了数字，值为该数值减2；大于10的数表示该六边形颜色为白色且包含了数字，数字为最后一位减1，这里23对应的数字为2。mapitem数组中每个字符串表示对应位置包含了箭头，例如：”1_4_1”表示第5行（从0开始）第2列（从0开始）有箭头，箭头序号为1；useritem数组中每个数字表示对应位置可用的箭头，这里“2,2,2,3”表示有4个箭头可用（可放置在任意一个六边形上），箭头序号分别为2，2，2，3。需要说明的是，箭头有以下四种类型，序号为0时表示无箭头。<br>序号：1　　　　图片：<img src="../images/2015/Trigger/arrow1.png" alt=""><br>序号：2　　　　图片：<img src="../images/2015/Trigger/arrow2.png" alt=""><br>序号：3　　　　图片：<img src="../images/2015/Trigger/arrow3.png" alt=""><br>序号：4　　　　图片：<img src="../images/2015/Trigger/arrow4.png" alt=""><br>&#160; &#160; &#160; &#160;levelmapss.json这个文件由于还不清楚作用（可能是附加关卡），所以先略过。</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>第一篇先写到这，如果有什么还不太明白的地方，可以联系我。</p>
]]></content>
      
        <categories>
            
            <category> Trigger </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Trigger </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[新的开始]]></title>
      <url>/blog/2015/New-beginning.html</url>
      <content type="html"><![CDATA[<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试测试测试测试测试测试测试测试测试测试测试测试<a id="more"></a></p>
<p>代码测试：</p>
<pre><code class="bash"><span class="comment">#include &lt;iostream&gt;</span>
using namespace std;　　
int main()　　
{　　
    cout &lt;&lt; <span class="string">"hello world!"</span> &lt;&lt; endl;　　
    <span class="built_in">return</span> 0;　
}
</code></pre>
<p>图片测试：<br><img src="../images/2015/New-beginning/Visual Studio.png" alt="Visual Studio"></p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
